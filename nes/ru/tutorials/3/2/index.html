<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Ромхакинг NES. Поиск свободных адресов</title>
		<meta name="description" content="Как искать свободные неиспользуемые адреса оперативной памяти. How to search for free unused RAM addresses">
		<meta name="keywords" content="">
		<link rel="icon" href="https://iromhacker.ru/favicon.png" type="image/png">
		<link href="https://iromhacker.ru/style.css" rel="stylesheet">
		<script src="https://iromhacker.ru/analytics.js"></script>
	</head>
	<body>
		<h1>Поиск свободных адресов</h1>
		<p>
			<center>
				<a class="return" href="https://iromhacker.ru/nes/ru/index.html">Вернуться на главную страницу</a>
			</center>
		</p>
		<p class="content">
			Содержание
		</p>
		<ul>
			<li><a href="../1/index.html">Поиск игровых адресов</a></li>
			<ul>
				<li><a href="../1-1/index.html">Виды адресов</a></li>
				<li><a href="../1-2/index.html">Двоичный поиск</a></li>
			</ul>
			<li>Поиск свободных адресов</li>
		</ul>
		<h2>Поиск свободных адресов</h2>
		<p>
			Если для написания своего кода ты хочешь выделить себе в RAM отдельные счетчики, индикаторы, некие новые игровые параметры, от которых будет зависеть выполнение кода в оригинальной игре, для этого требуется найти свободный адрес.
		</p>
		<p>
			Свободными адресами считаются те адреса, которые вообще не используются в игре для хранения каких-либо данных. Эти свободные адреса ты можешь применять при написании своего кода, чтобы положить в них свои личные данные.  
		</p>
		<p>
			Если ты уже расшифровал существующие игровые адреса и добавил на них комментарии, тебе будет проще найти свободные адреса. А если ты нашел в интернете исходный код игры, то можно просто посмотреть в нем какие адреса используются в игре, а значит оставшиеся адреса скорее всего являются свободными.
		</p>
		<h3>Какие адреса нужны для своего кода</h3>
		<h4>Zero Page</h4>
		<p>
			Если ты собираешься использовать инструкции с режимом адресации Indirect, потребуются минимум 2 соседних адреса в нулевой странице $0000-$00FF. Их не всегда можно найти, так как разработчики игр знают их важность и забирают их себе.
		</p>
		<p>
			Даже если тебе не удастся найти адреса в нулевой странице, то это не так страшно, с этим всегда можно что-то поделать.
		</p>
		<h4>Остальные</h4>
		<p>
			Адреса оставшегося диапазона $0100-$07FF практически одинаковые по ценности, и чем больше ты их найдешь, тем лучше.
		</p>
		<p>
			В первую очередь можно обратить внимание на адреса стека в диапазоне $0100-$01FF. Исключив адреса, используемые для хранения байтов адресов возврата из подпрограмм и выявив базовый свободный диапазон, начинать искать свободные адреса нужно с начала этого диапазона и продвигаясь вперед.
		</p>
		<h3>О чем следует знать перед поиском</h3>
		<h4>Очистка RAM</h4>
		<p>
			Первичный признак свободного адреса - байт в нем никогда не изменяется. Исключением является то, когда игра очищает RAM (записывает байты #$00) частично или полностью.
		</p>
		<p>
			Иногда игры очищают лишь некий дипазон вместо полной очистки RAM. Причем они могут делать это не один раз, например перед началом загрузки каждого уровня. Тебе следует выяснить, какие диапазоны адресов игра очищает и когда именно она это делает. По умолчанию байты в RAM выглядят так (настраивается в эмуляторе в Config -> RAM Init).
		</p>
		<p>
			<img src="1.png">
		</p>
		<p>
			Поставь эмулятор на паузу, сделай Hard Reset, и покадрово проматывай игру вперед горячей клавишей Frame Advance. Проверяй страницы RAM, в которых байты #$FF были перезаписаны на #$00, посчитай количество кадров от начала запуска игры.
		</p>
		<p>
			Очистка встречается в большинстве игр, но она еще не означает то, что адрес не является свободным, если игра перезаписывает байт на #$00. Однако даже если некий адрес диапазона, который игра очищает время от времени, действительно является свободным, очистка может помешать тебе регулярно использовать этот свободный адрес.
		</p>
		<h4>RNG</h4>
		<p>
			Во многих играх есть программы, вычисляющие RNG (рандом), используя одну или несколько страниц RAM, в которых байты меняются достаточно часто. Код будет считывать байты из большого диапазона адресов, но еще не означает то, что некий адрес этого диапазона не является свободным, даже если код считывает байт из адреса.
		</p>
		<h3>Методы поиска свободных адресов</h3>
		<p>
			Выбери опцию для просмотра способа поиска свободного адреса. Комбинируя эти способы, ты минимизируешь шанс того, что в какой-то нестандартный момент игра решит воспользоваться твоим личным адресом, который на самом деле изначально не являлся свободным, что испортит тебе твою программу.
		</p>
		<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Search')">RAM Search</td>
					<td class="tabLink" onclick="openTab(event, 'Mesen')">Эмулятор Mesen</td>
					<td class="tabLink" onclick="openTab(event, 'Breakpoints')">Брейкпоинты</td>
					<td class="tabLink" onclick="openTab(event, 'Instructions')">Поиск инструкций</td>
					<td class="tabLink" onclick="openTab(event, 'Other')">Прочие способы</td>
				</tr>
			</table>
		</p>
		<p>
			<div id="Search" class="tabcontent">
				<h2>RAM Search</h2>
				<h3>Предварительная настройка</h3>
				<p>
					В эмуляторе выбери опцию Config -> RAM Init -> Fill $00, чтобы изначально вся RAM была забита байтами #$00. Затем поставь эмулятор на паузу и сделай Hard Reset.
				</p>
				<p>
					В окне RAM Search выбери Equal To + Number of Changes 0, и поставь галочку Autosearch. Нажми кнопку Reset, если ты уже пользовался этим окном.
				</p>
				<p>
					<img src="4.png">
				</p>
				<h3>Фильтр списка адресов</h3>
				<p>
					После чего сними эмулятор с паузы, начни играть в игру и продолжай играть как можно дольше, используя все существующие игровые возможности. Желательно записать свое прохождение на Movie (фильм) в эмуляторе через File -> Movie, который, вероятно, понадобится тебе в дальнейшем при поиске брейкпоинтов.
				</p>
				<p class="tip">
					Еще рекомендую активировать окно Code/Data Logger для сбора информации по байтам ROM'а в файл .cdl, пока ты проходишь игру. Этот файл может пригодиться в будущем тебе или кому-то еще.
				</p>
				<p>
					Во время прохождения игры окно RAM Search будет постоянно фильтровать список адресов, оставляя лишь те, которые ни разу не изменяли свое значение.
				</p>
				<p class="tip">
					Код очистки RAM не повлияет на количество изменений, так как изначально в RAM везде был записан байт #$00, следовательно по мнению RAM Search запись байта #$00 не является изменением байта.
				</p>
				<h3>Пометка адресов</h3>
				<p>
					Когда наиграешься, кликай правой кнопкой на оставшихся адресах списка, чтобы перейти на эти адреса в Hex Editor'е. Помечай закладками потенциально свободные адреса, выделяя их зеленым цветом.
				</p>
				<p class="tip">
					Не всегда стоит ставить закладки на адреса в крупных диапазонах RAM, таких как спрайты, музыка, данные уровня и так далее, поскольку использовать эти свободные адреса может быть опасно из-за возможного использования их игрой.
				</p>
			</div>
		</p>
		<p>
			<div id="Mesen" class="tabcontent">
				<h2>Эмулятор Mesen</h2>
				<p>
					Hex Editor в эмуляторе FCEUX подсвечивает только байты, которые изменяют свое значение на другое относительно предыдущего значения. В эмуляторе <a href="https://www.mesen.ca" target="_blank">Mesen</a> Hex Editor обладает более продвинутой подсветкой. Он вызывается через Debug -> Memory Tools, а подсветка настраивается во View -> Memory Access Highlighting.
				</p>
				<p>
					<img src="2.png">
				</p>
				<p class="tip">
					По умолчанию скорость обновления окна - 30 FPS, это можно изменить в настройке Auto-refresh Speed. Скорость обновления не влияет на сбор данных о чтении/записи байтов для их подсветки.
				</p>
				<p>
					Красными подсвечиваются те адреса, в которые код игры что-то записывал (независимо от предыдущего значения байта), а синими - если байт из адреса был считан кодом. Подсветка байтов полностью сбрасывается после Reset.
				</p>
				<p>
					Данные о подсветке эмулятора Mesen можно использовать в комбинации с поиском RAM Search и брейкпоинтами в эмуляторе FCEUX. В некоторых случаях также будет полезно переключиться на вкладку Access Counters для просмотра счетчиков чтений и записей адресов RAM.
				</p>
				<h3>Настройка подсветки</h3>
				<p>
					В настройке Fade Speed (скорость исчезновения подсветки) запиши в Custom количество кадров = 1, после чего сделай Hard Reset и покадрово промотай игру (Опции -> Настройка -> Горячие клавиши -> Run Single Frame) в ожидании того, когда игра очистит RAM. После чего измени Fade Speed на Do not fade, чтобы подсветка не исчезала, и начинай проходить игру.
				</p>
				<p>
					Во время прохождения код будет работать с адресами, что отобразится в суммарной подсветке адресов. Черные адреса без подсветки будут являться потенциально свободными.
				</p>
				<h4>RNG</h4>
				<p>
					Если код игры считывает диапазон адресов, весь этот диапазон окажется подсвеченным. Будет лучше полностью отключить код RNG, или избавиться от чтения адресов, например заменив инструкции чтения на инструкции <text class="opcode">NOP</text>.
				</p>
				<p class="tip">
					Еще можно в настройках подсветки снять галочку Read, но это приведет к тому, что ты не узнаешь какие адреса в других диапазонах были считаны.
				</p>
				<h3>Недостатки подсветки</h3>
				<p>
					Каждое сохранение эмулятора хранит свой собственный список подсвеченных байтов, и эти списки нельзя суммировать. Это означает, что не получится пройти игру всевозможными путями и получить общий список подсвеченных байтов, используя сохранения перед такими развилками.
				</p>
				<p class="tip">
					Теоретически можно добиться суммирования списка подсвеченных байтов, вручную отредактировав файлы сохранений.
				</p>
			</div>
		</p>
		<p>
			<div id="Breakpoints" class="tabcontent">
				<h2>Брейкпоинты</h2>
				<p>
					Когда ты получил список потенциально свободных адресов, стоит проверить их на то, что код игры с ними не работает. Существующие комментарии на игровые адреса RAM помогут тебе прочитать код. Если ты выяснил, что адрес не является свободным, снимай с него закладку и переходи к исследованию следующего адреса.
				</p>
				<p>
					Для экономии времени нужно поставить брейкпоинты на как можно большее количество потенциально свободных адресов. Брейкпоинты должны быть активны постоянно, пока ты повторно проходишь игру. Удалять стоит лишь брейкпоинты на те адреса, которые по твоему мнению оказались занятыми игрой.
				</p>
				<p>
					Если ты воспроизводишь Movie своего прохождения, настрой горячую клавишу Toogle Turbo, чтобы проматывать прохождение с максимальной скоростью без необходимости удержания кнопки Turbo. Для увеличения скорости отключи лишние окна в эмуляторе и в целом снизь нагрузку на компьютер.
				</p>
				<h3>Read</h3>
				<p>
					Если срабатывает Read брейкпоинт, значит код игры считывает адрес. Нужно осмотреться по коду и понять с какой целью игра пытается считать адрес. Если это код RNG, можно смело ставить Forbid брейкпоинт на адресе инструкции и продолжать дальшей поиск других срабатываний Read брейкпоинта.
				</p>
				<h3>Write</h3>
				<p>
					Если срабатывает Write брейкпоинт, значит код игры делает запись в этот адрес. Выясни с какой целью происходит запись. Если это запись с целью очистки диапазона RAM, ставь Forbid на адресе инструкции и пробуй искать другие срабатывания.
				</p>
			</div>
		</p>
		<p>
			<div id="Instructions" class="tabcontent">
				<h2>Поиск инструкций</h2>
				<p>
					Даже если брейкпоинты не срабатывают на потенциально свободных адресах, это еще не гарантирует то, что адрес действительно свободный. Ты вполне мог не затронуть игровую ситуацию, когда игре понадобится этот адрес.
				</p>
				<p>
					Для поиска инструкций нужно знать опкоды этих инструций, а также существующие режимы адресации. Первичный поиск осуществляется через попытку нахождения инструкций <text class="opcode">LDA</text> для чтения и <text class="opcode">STA</text> для записи. Затем следует искать <text class="opcode">INC</text>, <text class="opcode">DEC</text>, и другие популярные инструкции.
				</p>
				<h3>Поиск байтов</h3>
				<p>
					Если адрес находится в диапазоне $0100-$07FF, нужно искать инструкции с режимом адресации Absolute. Например, для поиска адреса $0123 ищи байты AD 23 01, чтобы найти инструкции <text class="opcode">LDA</text> <text class="address">$0123</text>, и 8D 23 01 для инструкций <text class="opcode">STA</text> <text class="address">$0123</text>.
				</p>
				<p>
					Для поиска адреса в диапазоне $0000-$00FF скорее всего используется режим адресации Zero Page. Для поиска $0023 нужно искать A5 23/85 23, чтобы найти инструкции <text class="opcode">LDA</text> <text class="address">$23</text>/<text class="opcode">STA</text> <text class="address">$23</text>.
				</p>
				<p class="tip">
					В редких случаях для адресов нулевой страницы применяется режим адресации Absolute, поэтому для подстраховки стоит поискать AD 00 23 и 8D 00 23.
				</p>
				<h4>Search with Wildcards</h4>
				<p>
					Данный вид поиска присутствует в некоторых Hex-редакторах, например в <a href="https://www.sweetscape.com/010editor" target="_blank">010 Editor</a>, работа с которым будет описана на главной странице.
				</p>
				<p>
					Если ты ищешь инструкции с адресом $0123, ты можешь ввести в поиск "? 23 01", и Hex-редактор покажет тебе все совпадения, в которых второй и третий байт являются 23 и 01, а первый байт может быть любым. По первому байту ты сможешь определить, действительно ли он является опкодом инструкции, или это просто случайный набор байтов.
				</p>
				<p>
					<img src="3.png">
				</p>
				<h3>Поиск текста</h3>
				<p>
					Это менее удобный способ поиска по сравнению с поиском байтов. Потребуется скопировать весь код из Debugger'а, причем изо всех PRG банков сразу, вставить этот код в текстовый редактор, а затем попробовать найти адреса в нем. Для копирования лучше пользоваться автокликером.
				</p>
				<p class="tip">
					Нужно уметь отличать код от байтов данных, которые Debugger интерпретировал как код, чтобы убедиться, что это действительно реальная инструкция, а не случайный набор байтов.
				</p>
				<h3>Недостатки поиска</h3>
				<p>
					Не все инструкции можно найти прямым поиском. Твой потенциальный свободный адрес может входить в некий диапазон адресов, вычисляющийся через режим адресации Indexed, начальный адрес которого является другой адрес.
				</p>
				<p>
					Например, если твой адрес $0123, он может вычисляться кодом через инструкцию <text class="opcode">LDA</text> <text class="address">$0120</text><text class="opcode">,X</text> при условии X = $03. Следовательно при попытке поиска адрес $0123 ты не найдешь этой инструкции, но технически код игры все же может работать с этим адресом.
				</p>
				<p>
					Если адрес вычисляется через режим адресации Indirect, которые выглядят примерно так - <text class="opcode">LDA (</text><text class="address">$FE</text><text class="opcode">),Y</text>, ты опять же не найдешь инструкции с этим адресом, поскольку такая инструкция вычисляет адрес с помощью регистра Y и соседних адресов Zero Page, и в байты инструкции не входит адрес $0123.
				</p>
			</div>
		</p>
		<p>
			<div id="Other" class="tabcontent">
				<h2>Прочие способы</h2>
				<h3>Временные свободные адреса</h3>
				<p>
					Если тебе не требуется свободный адрес на постоянной основе, а лишь на какое-то определенное время, например для некого игрового экрана или для быстрого промежуточного вычисления, то полностью свободные адреса искать не обязательно.
				</p>
				<h4>Игровые адреса</h4>
				<p>
					Не все игровые адреса регулярно используются игрой. Например, адреса с координатами объектов могут не использоваться на экране с логотипом. Это значит, что до тех пор, пока ты не приступишь непосредственно к игровому процессу прохождения уровней, ты можешь временно использовать эти адреса в качестве свободных.
				</p>
				<p>
					Разработчики игр тоже знают о такой возможности, и иногда сами применяют выделенные адреса для различных игровых функций не по прямому назначению.
				</p>
				<p>
					Если ты решил воспользоваться этим способом, следует при помощи брейкпоинтов убедиться, что код игры не будет сразу считывать байты в этих адресах, а первым делом перейдет к записи.
				</p>
				<p>
					Например, если ты взял себе адрес с координатами игроков и оставил в нем какой-то байт, и в то же время игра самостоятельно его не перезаписала перед загрузкой уровня, это приведет к тому, что объект появится на экране в неположенном месте.
				</p>
				<h4>Временные адреса</h4>
				<p>
					В каждой игре есть несколько адресов, обычно в нулевой странице, которые специально зарезервированы для промежуточных вычислений или для временного использования инструкций с режимом адресации Indirect.
				</p>
				<p>
					Применяя такие адреса самостоятельно для аналогичных целей, нужно также убедиться, что байты, которые останутся в этих адресах после твоей работы с ними, не потребуются игре и будут перезаписаны перед чтением.
				</p>
				<p>
					В качестве временных адресов еще можно использовать и игровые адреса, если предварительно сохранить байт из адреса в стеке, выполнить промежуточное вычисление, а затем вернуть байт в адрес на место. Для этого подойдет практически любой игровой адрес.
				</p>
				<h3>Насильное выделение свободных адресов</h3>
				<p>
					Если по каким-то причинам тебе вообще не удалось найти свободных адресов, что почти нереально, есть несколько способов выделить себе свободные адреса.
				</p>
				<h4>Адреса спрайтов</h4>
				<p>
					Диапазон для параметров спрайтов занимает 256 байтов, которые ежекадрово копируются в OAM Memory после записи в регистр видеопроцессора $4014. Предположим, что диапазон для спрайтов является $0200-$02FF.
				</p>
				<p>
					Ты можешь немного отредактировать код, чтобы он, к примеру, начинал запись параметров спрайтов не с адреса $0200, а с адреса $0204, либо чтобы он заканчивал запись не в $02FF, а в $02FB. Это позволит тебе выделить 4 свободных адреса, пожертвовав удалением одного спрайта с экрана, что практически не будет заметно.
				</p>
				<p>
					Если ты также используешь первый из этих четырех адресов, который отвечает за Y координату спрайта, нужно убедиться, что в нем будет записан байт #$F0 или выше перед записью в регистр $4014, в противном случае на экране может постоянно появляться какой-то рандомный спрайт.
				</p>
				<h4>Удаление игровой функции</h4>
				<p>
					Можно вырезать из игры какую-то относительно бесполезную функцию, например демо-режим. Поискав адреса, которые используются исключительно для демо-режима, отключи переход в этот режим, тем самым высвободив себе адреса, которые задействованы игрой для этой функции.
				</p>
				<h4>Игровые адреса</h4>
				<p>
					Байт - набор из 8-ми битов. Но не всем программам нужен каждый из этих битов у байта в адресе. Например, если адрес отвечает за некую игровую опцию с четырьмя вариантами, байт в нем может быть максимум #$03, а значит используются лишь первые 2 бита, оставляя свободными остальные 6.
				</p>
				<p>
					В этих свободных битах ты можешь хранить свою собственную информацию, однако это потребует отредактировать код везде, где считывается/записывается байт в адресе, чтобы он не затрагивал последние 6 битов.
				</p>
			</div>
		</p>
		<script src="https://iromhacker.ru/spoiler.js"></script>
		<script src="https://iromhacker.ru/tab.js"></script>
	</body>
</html>