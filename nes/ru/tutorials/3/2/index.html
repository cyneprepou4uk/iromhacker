<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Ромхакинг NES. Поиск свободных адресов</title>
		<meta name="description" content="Как искать свободные неиспользуемые адреса оперативной памяти. How to search for free unused RAM addresses">
		<meta name="keywords" content="">
		<link rel="icon" href="https://iromhacker.ru/favicon.png" type="image/png">
		<link href="https://iromhacker.ru/style.css" rel="stylesheet">
		<script src="https://iromhacker.ru/analytics.js"></script>
	</head>
	<body>
		<h1>Поиск свободных адресов</h1>
		<p>
			<center>
				<a class="return" href="https://iromhacker.ru/nes/ru/index.html">Вернуться на главную страницу</a>
			</center>
		</p>
		<p class="content">
			Содержание
		</p>
		<ul>
			<li><a href="../1/index.html">Поиск игровых адресов</a></li>
			<ul>
				<li><a href="../1-1/index.html">Виды адресов</a></li>
				<li><a href="../1-2/index.html">Двоичный поиск</a></li>
			</ul>
			<li><a href="../2/index.html">Поиск свободных адресов</a></li>
		</ul>
		<h2>Поиск свободных адресов</h2>
		<p>
			Если для написания своего кода ты хочешь выделить себе в RAM отдельные счетчики, индикаторы, некие новые игровые параметры, от которых будет зависеть выполнение кода в оригинальной игре, для этого требуется найти свободный адрес.
		</p>
		<p>
			Свободными адресами считаются те адреса, которые вообще не используются в игре для хранения каких-либо данных. Эти адреса ты можешь использовать при написании своего кода, чтобы положить в них свои личные данные.  
		</p>
		<p>
			Если ты уже расшифровал существующие игровые адреса и добавил на них комментарии, тебе будет проще найти свободные адреса. А если ты нашел в интернете исходный код игры, то можно просто посмотреть в нем какие адреса используются в игре, а значит оставшиеся адреса скорее всего являются свободными.
		</p>
		<h3>Какие адреса нужны для своего кода</h3>
		<h4>Zero Page</h4>
		<p>
			Если ты собираешься использовать инструкции с режимом адресации Indirect, потребуются минимум 2 соседних адреса в нулевой странице $0000-$00FF. Их не всегда можно найти, так как разработчики игр знают их важность и забирают их себе.
		</p>
		<p>
			Даже если тебе не удастся найти адреса в нулевой странице, то это не так страшно, с этим всегда можно что-то поделать.
		</p>
		<h4>Остальные</h4>
		<p>
			Адреса оставшегося диапазона $0100-$07FF практически одинаковые по ценности, и чем больше ты их найдешь, тем лучше.
		</p>
		<p>
			В первую очередь я бы посоветовал обратить внимание на адреса стека в диапазоне $0100-$01FF. Исключив адреса, используемые для хранения и выявив базовый свободный диапазон, начинать искать свободные адреса нужно с начала этого диапазона и продвигаясь вперед.
		</p>
		<h3>О чем следует знать перед поиском</h3>
		<h4>Очистка RAM</h4>
		<p>
			Первичный признак свободного адреса - байт в нем никогда не изменяется. Исключением является то, когда игра очищает RAM (записывает байты #$00) частично или полностью.
		</p>
		<p>
			Иногда игры очищают лишь некий дипазон вместо полной очистки RAM. Причем они могут делать это не один раз, например перед началом загрузки каждого уровня. Тебе следует выяснить, какие диапазоны адресов игра очищает и когда именно она это делает. По умолчанию байты в RAM выглядят так (настраивается в эмуляторе в Config -> RAM Init).
		</p>
		<p>
			<img src="1.png">
		</p>
		<p>
			Поставь эмулятор на паузу, сделай Hard Reset, и покадрово проматывай игру вперед горячей клавишей Frame Advance. Проверяй страницы RAM, в которых байты #$FF были перезаписаны на #$00, посчитай количество кадров от начала запуска игры.
		</p>
		<p>
			Очистка встречается в большинстве игр, но она еще не означает то, что адрес не является свободным, если игра перезаписывает байт на #$00. Однако даже если некий адрес диапазона, который игра очищает время от времени, действительно является свободным, очистка может помешать тебе регулярно использовать этот свободный адрес.
		</p>
		<h4>RNG</h4>
		<p>
			Во многих играх есть программы, вычисляющие RNG (рандом), используя одну или несколько страниц RAM, в которых байты меняются достаточно часто. Код будет считывать байты из большого диапазона адресов, но еще не означает то, что некий адрес этого диапазона не является свободным.
		</p>
		<h3>Методы поиска свободных адресов</h3>
		<p>
			Выбери опцию для просмотра способа поиска свободного адреса. Комбинируя эти способы, ты минимизируешь шанс того, что в какой-то нестандартный момент игра решит воспользоваться твоим личным адресом, который на самом деле изначально не являлся свободным, что испортит тебе твою программу.
		</p>
		<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Search')">RAM Search</td>
					<td class="tabLink" onclick="openTab(event, 'Mesen')">Эмулятор Mesen</td>
					<td class="tabLink" onclick="openTab(event, 'Breakpoints')">Брейкпоинты</td>
					<td class="tabLink" onclick="openTab(event, 'Instructions')">Поиск инструкций</td>
					<td class="tabLink" onclick="openTab(event, 'Other')">Прочие способы</td>
				</tr>
			</table>
		</p>
		<p>
			<div id="Search" class="tabcontent">
				<h2>RAM Search</h2>
				<h3>Предварительная настройка</h3>
				<p>
					В эмуляторе выбери опцию Config -> RAM Init -> Fill $00, чтобы изначально вся RAM была забита байтами #$00. Затем поставь эмулятор на паузу и сделай Hard Reset.
				</p>
				<p>
					В окне RAM Search выбери Equal To + Number of Changes 0, и поставь галочку Autosearch. Нажми кнопку Reset, если ты уже пользовался этим окном.
				</p>
				<p>
					<img src="4.png">
				</p>
				<h3>Фильтр списка адресов</h3>
				<p>
					После чего сними эмулятор с паузы, начни играть в игру и продолжай играть как можно дольше, используя все существующие игровые возможности. Желательно записать свое прохождение на Movie (фильм) в эмуляторе через File -> Movie, который, вероятно, понадобится тебе в дальнейшем при поиске брейкпоинтов.
				</p>
				<p class="tip">
					Еще рекомендую активировать окно Code/Data Logger для сбора информации по байтам ROM'а в файл .cdl, который может пригодиться в будущем.
				</p>
				<p>
					Во время прохождения игры, окно RAM Search будет постоянно фильтровать список адресов, оставляя лишь те, которые ни разу не изменяли свое значение.
				</p>
				<p>
					Код очистки RAM не повлияет на количество изменений, так как изначально в RAM везде был записан байт #$00, следовательно по мнению RAM Search запись байта #$00 не является изменением байта.
				</p>
				<h3>Пометка адресов</h3>
				<p>
					Когда наиграешься, кликай правой кнопкой на оставшихся адресах списка, чтобы перейти на эти адреса в Hex Editor'е. Помечай закладками потенциально свободные адреса, выделяя их зеленым цветом.
				</p>
				<p class="tip">
					Не всегда стоит ставить закладки на адреса в крупных диапазонах RAM, таких как спрайты, музыка, данные уровня и так далее, поскольку использовать эти свободные адреса может быть опасно из-за возможного использования их игрой.
				</p>
			</div>
		</p>
		<p>
			<div id="Mesen" class="tabcontent">
				<h2>Эмулятор Mesen</h2>
				<p>
					Hex Editor в эмуляторе FCEUX подсвечивает только байты, которые изменяют свое значение на другое относительно предыдущего значения. В эмуляторе <a href="https://www.mesen.ca" target="_blank">Mesen</a> Hex Editor обладает более продвинутой подсветкой. Он вызывается через Debug -> Memory Tools, а подсветка настраивается во View -> Memory Access Highlighting.
				</p>
				<p>
					<img src="2.png">
				</p>
				<p>
					Красными подсвечиваются те адреса, в которые код игры что-то записывал (независимо от предыдущего значения байта), а синими - если байт из адреса был считан кодом. Подсветка байтов полностью сбрасывается после Reset.
				</p>
				<p>
					Данные о подсветке эмулятора Mesen можно использовать в комбинации с поиском RAM Search и брейкпоинтами в эмуляторе FCEUX. В некоторых случаях также будет полезно переключиться на вкладку Access Counters для просмотра счетчиков чтений и записей адресов RAM.
				</p>
				<h3>Настройка подсветки</h3>
				<p>
					В настройке Fade Speed (скорость исчезновения подсветки) запиши в Custom количество кадров = 1, после чего сделай Hard Reset и покадрово промотай игру (Frame Advance здесь называется Run Single Frame) в ожидании того, когда игра очистит RAM. После чего измени Fade Speed на Do not fade, чтобы подсветка не исчезала, и начинай проходить игру.
				</p>
				<p>
					Во время прохождения код будет работать с адресами, что отобразится в подсветке. Черные адреса без подсветки будут являться потенциально свободными.
				</p>
				<h4>RNG</h4>
				<p>
					Если код игры считывает диапазон адресов, весь этот диапазон окажется подсвеченным. Будет лучше полностью отключить код RNG, или избавиться от чтения адресов, например заменив инструкции чтения на инструкции <text class="opcode">NOP</text>.
				</p>
				<p class="tip">
					Еще можно в настройках подсветки снять галочку Read, но это приведет к тому, что ты не узнаешь какие адреса в других диапазонах были считаны.
				</p>
				<h3>Недостатки подсветки</h3>
				<p>
					Каждое сохранение эмулятора хранит свой собственный список подсвеченных байтов, и эти списки нельзя суммировать. Это означает, что не получится пройти игру всевозможными путями и получить общий список подсвеченных байтов, используя сохранения перед такими развилками.
				</p>
				<p class="tip">
					Суммирование списка подсвеченных байтов можно добиться лишь вручную отредактировав файлы сохранений.
				</p>
			</div>
		</p>
		<p>
			<div id="Breakpoints" class="tabcontent">
				<h2>Брейкпоинты</h2>
				<p>
					Когда ты получил список потенциально свободных адресов, стоит проверить их на то, что код игры с ними не работает. Существующие комментарии на игровые адреса RAM помогут тебе прочитать код. Если ты выяснил, что адрес не является свободным, снимай с него закладку и переходи к исследованию следующего адреса.
				</p>
				<p>
					Брейкпоинты должны быть активны постоянно, пока ты повторно проходишь игру. Удалять стоит лишь брейкпоинты на те адреса, которые по твоему мнению оказались занятыми игрой.
				</p>
				<p>
					Если ты воспроизводишь Movie своего прохождения, настрой горячую клавишу Toogle Turbo, чтобы проматывать прохождение с максимальной скоростью без необходимости удержания кнопки Turbo. Для увеличения скорости отключи лишние окна в эмуляторе и в целом снизь нагрузку на компьютер.
				</p>
				<h3>Read</h3>
				<p>
					Если срабатывает Read брейкпоинт, значит код игры считывает адрес. Нужно осмотреться по коду и понять с какой целью игра пытается считать адрес. Если это код RNG, можно смело ставить Forbit брейкпоинт на адресе инструкции и продолжать дальшей поиск других срабатываний Read брейкпоинта.
				</p>
				<h3>Write</h3>
				<p>
					Если срабатывает Write брейкпоинт, значит код игры делает запись в этот адрес. Выясни с какой целью происходит запись. Если это запись с целью очистки диапазона RAM, ставь Forbit на адресе инструкции и пробуй искать другие срабатывания.
				</p>
			</div>
		</p>
		<p>
			<div id="Instructions" class="tabcontent">
				<h2>Поиск инструкций</h2>
				<p>
					Даже если брейкпоинты не срабатывают на потенциально свободных адресах, это еще не гарантирует то, что адрес действительно свободный. Ты вполне мог не затронуть игровую ситуацию, когда игре понадобится этот адрес.
				</p>
				<p>
					Для поиска инструкций нужно знать опкоды этих инструций, а также существующие режимы адресации. Первичный поиск осуществляется через попытку нахождения инструкций <text class="opcode">LDA</text> для чтения и <text class="opcode">STA</text> для записи. Затем следует искать <text class="opcode">INC</text>, <text class="opcode">DEC</text> и другие популярные инструкции.
				</p>
				<h3>Поиск байтов</h3>
				<p>
					Если адрес находится в диапазоне $0100-$07FF, нужно искать инструкции с режимом адресации Absolute. Например, для поиска адреса $0123 ищи байты AD 23 01, чтобы найти инструкции <text class="opcode">LDA</text> <text class="address">$0123</text>, и 8D 23 01 для инструкций <text class="opcode">STA</text> <text class="address">$0123</text>.
				</p>
				<p>
					Для поиска адреса в диапазоне $0000-$00FF скорее всего используется режим адресации Zero Page. Для поиска $0023 нужно искать A5 23/85 23, чтобы найти инструкции <text class="opcode">LDA</text> <text class="address">$23</text>/<text class="opcode">STA</text> <text class="address">$23</text>.
				</p>
				<p>
					В редких случаях для адресов нулевой страницы применяется режим адресации Absolute, поэтому для подстраховки стоит поискать AD 00 23 и 8D 00 23.
				</p>
				<h4>Search with Wildcards</h4>
				<p>
					Данный вид поиска присутствует в некоторых Hex-редакторах, например в <a href="https://www.sweetscape.com/010editor" target="_blank">010 Editor</a>, работа с которым будет описана на главной странице.
				</p>
				<p>
					Если ты ищешь инструкции с адресом $0123, ты можешь ввести в поиск "? 23 01", и Hex-редактор покажет тебе все совпадения, в которых второй и третий байт являются 23 и 01, а первый байт может быть любым. По первому байту ты сможешь определить, действительно ли он является опкодом инструкции, или это просто случайный набор байтов.
				</p>
				<p>
					<img src="3.png">
				</p>
				<h3>Поиск текста</h3>
				<p>
					Это менее удобный способ поиска по сравнению с поиском байтов. Потребуется скопировать весь код из Debugger'а, причем изо всех PRG банков сразу, вставить этот код в текстовый редактор, а затем попробовать найти адреса в нем. Для копирования лучше пользоваться автокликером.
				</p>
				<h3>Недостатки поиска</h3>
				<p>
					Не все инструкции можно найти прямым поиском. Твой потенциальный свободный адрес может входить в некий диапазон адресов, вычисляющийся через режим адресации Indexed, начальный адрес которого является другой адрес.
				</p>
				<p>
					Например, если твой адрес $0123, он может вычисляться кодом через инструкцию <text class="opcode">LDA</text> <text class="address">$0120</text><text class="opcode">,X</text> при условии X = $03. Следовательно при попытке поиска адрес $0123 ты не найдешь этой инструкции, но технически код игры все же может работать с этим адресом.
				</p>
				<p>
					Если адрес вычисляется через режим адресации Indirect, которые выглядят примерно так - <text class="opcode">LDA (</text><text class="address">$FE</text><text class="opcode">),Y</text>, ты опять же не найдешь инструкции с этим адресом, поскольку такая инструкция вычисляет адрес с помощью регистра Y и соседних адресов Zero Page, и в байты инструкции не входит адрес $0123.
				</p>
			</div>
		</p>
		<p>
			<div id="Other" class="tabcontent">
				<h2>Прочие способы</h2>
				<h3>Временные свободные адреса</h3>
				<p>
					
				</p>
				<h3>Насильное выделение свободных адресов</h3>
				<p>
					Если по каким-то причинам тебе вообще не удалось найти свободных адресов, что почти нереально, есть несколько способов выделить себе свободные адреса.
				</p>
				<h4>Адреса спрайтов</h4>
				<p>
					Диапазон для параметров спрайтов занимает 256 байтов, которые ежекадрово копируются в OAM Memory после записи в регистр видеопроцессора $4014. Предположим, что диапазон для спрайтов является $0200-$02FF.
				</p>
				<p>
					Ты можешь немного отредактировать код, чтобы он, к примеру, начинал запись параметров спрайтов не с адреса $0200, а с адреса $0204, либо чтобы он заканчивал запись не в $02FF, а в $02FB. Это позволит тебе выделить 4 свободных адреса, пожертвовав удалением одного спрайта с экрана, что практически не будет заметно.
				</p>
				<p>
					Если ты также используешь первый из этих четырех адресов, который отвечает за Y координату спрайта, нужно убедиться, что в нем будет записан байт #$F0 или выше перед записью в регистр $4014, в противном случае на экране может постоянно появляться какой-то рандомный спрайт.
				</p>
				<h4>Удаление игровой функции</h4>
				<p>
					Можно вырезать из игры какую-то относительно бесполезную функцию, например демо-режим, тем самым высвободив себе адреса, которые используются этой функцией.игры.
				</p>
				<h2>Если ничего не найдено</h2>
				<h3>Zero Page</h3>
				<p>
					Даже если свободных адресов в нулевой странице ты не нашел, это не критично. Ты можешь взять какой-нибудь из уже существующих адресов.
				</p>
				<h3>Спрайты</h3>
				<p>
					Потребуется каждый раз, когда код пишет в $4014, предварительно сохранять байты из своих адресов в стеке, затем перезаписывать адреса так, чтобы не появлялись левые спрайты (запись в Y байт #$F0 или выше), а после записи вытаскивать их оттуда и запихивать в адреса обратно. Но если стек в состоянии выдержать 4 байта, так может и адреса там свободные имеются?
				</p>
				<h3>Вырезать код</h3>
				<p>
					Удалить какую-то ненужную на твой взгляд функцию, требующая много адресов.
				</p>
				<p>
					Практически нереально, чтобы тебе не удалось найти ни одного свободного адреса. Но предположим, что это действительно так. Что теперь?
				</p>
				<p class="tip">
					Временные свободные адреса. Если игра что-то записывает в адрес перед тем, как ты выполняешь подпрограмму, ты можешь смело использовать этот адрес для временных вычислений. Технически временным адресом является тот адрес, которому не требуется текущее значение
				</p>
				<p class="tip">
					Вариант поиска свободных адресов через мувик. Пишешь прохождение, затем замораживаешь байт в адресе или адресах. Воспроизводишь игру в ускоренном режиме, найти toggle turbo. Если без десинхов, то адрес свободен
				</p>
				<p>
					Например, тебе надо сделать так, чтобы при удержании кнопки Select 3 секунды ты переходил на следующий игровой уровень. В оригинале навряд ли будет существовать такой таймер, поэтому ты создаешь его самостоятельно, выбрав любой понравившийся свободный адрес. Как только таймер достигает нужного значения, выполняешь код переключения уровня.
				</p>
				<h3>Временные свободные адреса</h3>
				<p>
					Их даже лучше использовать для адресации Indirect, когда требуются адреса в нулевой странице.
				</p>
				<p class="tip">
					Нужно учитывать, что если адрес существует, он не обязательно будет использоваться постоянно. Например если адрес хранит координаты врага, а ты в данный момент находишься на экране с логотипом, эти адреса не будут считаны и в них не будет записи, но они остаются зарезервированы игрой во время геймплея.
				</p>
				<p>
					Если по каким-то причинам ты не нашел свободных адресов, но и постоянный свободный адрес тебе не нужен, ты можешь взять практически любой другой адрес и сделать его временным. В отличие от свободных адресов, временными свободными адресами считаются те, которые хоть и зарезервированы в RAM для некой игровой функции, но в данный игровой момент игре они без надобности. Например, находясь на начальном экране с логотипом, игре вряд ли понадобятся адреса, в которых хранится координаты игроков.
				</p>
				<p>
					Нужно знать как именно работает игровой адрес. Конкретнее, тебе стоит знать можно ли тебе оставлять в этом адресе какие-то остаточные байты от своего кода. Если это адрес координаты, то вряд ли что-то случится, если ты забудешь в нем какой-то байт. Скорее всего игра перед загрузкой уровня запишет координаты объектам, а только потом отобразит графику и начнет считывать координаты.
				</p>
				<p>
					Чтобы убедиться в безопасности использовния, поставь на него Read и Write брейкпоинты, и посмотри какой из них сработает первым. Если первым сработает Write, значит игре не будет интересно какой байт сейчас находится в адресе, она записывает свое значение. Если же сработает Read, а далее по коду будет проверка байта этого адреса, значит по каким-то причинам игре нужно знать что за байт сейчас в нем лежит. В этом случае нужно либо 
				</p>
				<p class="tip">
					Нужно посмотреть все игровые ситуации. Например, если ты находишься на экране с логотипом и жмешь старт, и первым срабатывает Write, вспомни какие еще бывают игровые функции, которые можно делать на экране с логотипом. Возможно там запускается демо-режим если ничего не нажимать. Может быть есть возможность зайти/поменять какие-то опции. Все это надо обязательно проверить.
				</p>
			</div>
		</p>
		<script src="https://iromhacker.ru/spoiler.js"></script>
		<script src="https://iromhacker.ru/tab.js"></script>
	</body>
</html>