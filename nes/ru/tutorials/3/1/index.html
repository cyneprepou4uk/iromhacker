<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Ромхакинг NES. Поиск RAM адресов</title>
		<meta name="description" content="Базовые методы поиска адреса в оперативной памяти и описание адресов. Basic methods of searching RAM addresses and their description">
		<meta name="keywords" content="">
		<link rel="icon" href="https://iromhacker.ru/favicon.png" type="image/png">
		<link href="https://iromhacker.ru/style.css" rel="stylesheet">
		<script src="https://iromhacker.ru/analytics.js"></script>
	</head>
	<body>
		<h1>Поиск RAM адресов</h1>
		<p>
			<center>
				<a class="return" href="https://iromhacker.ru/nes/ru/index.html">Вернуться на главную страницу</a>
			</center>
		</p>
		<p class="content">
			Содержание
		</p>
		<ul>
			<li>Поиск игровых адресов</li>
			<ul>
				<li>Виды адресов</li>
				<li>Двоичный поиск</li>
			</ul>
			<li>Поиск свободных адресов</li>
		</ul>
		<h2>Поиск игровых адресов</h2>
		<p class="notice">
			Для ознакомлениея с разделом требуется базовое знание окон Hex Editor и Debugger, а также инструкций процессора.
		</p>
		<p>
			В RAM (диапазон адресов $0000-$07FF в NES Memory) хранятся динамические данные игрового процесса.
		</p>
		<p>
			В этом разделе будет рассказано про то, как именно в RAM хранятся некоторые данные, чтобы ты примерно знал что надо искать при просмотре адресов во время игры, а также про различные метода поиска этих адресов.
		</p>
		<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Why')">Зачем искать адреса</td>
					<td class="tabLink" onclick="openTab(event, 'Map')">Карта RAM</td>
					<td class="tabLink" onclick="openTab(event, 'Search')">Методы поиска адресов</td>
				</tr>
			</table>
		</p>
		<p>
			<div id="Why" class="tabcontent">
				<h2>Зачем искать адреса</h2>
				<p>
					Чтобы что-то изменить в игре, нужно знать адрес, который отвечает за ту функцию, которую ты хочешь изменить. Зная правильный адрес, ты ставишь на него Read и/или Write брейкпоинт для нахождения связанного с этим адресом кода. 
				</p>
				<p>
					Например, найдя адрес с количеством жизней игрока и поставив на него Write брейкпоинт, ты обнаружишь код, который записывает это начальное количество/изменяет его после смерти игрока.
				</p>
				<p>
					Если поставить Read брейкпоинт, тебе повстречаются программы, которые считывают это количество и что-то с ним делают, наподобие вывода количества жизней на экране или проверки на #$00 для завершения игры.
				</p>
				<p>
					Когда код найден, то с соответствующими знаниями инструкций процессора ты сможешь отредактировать код по своему усмотрению, к примеру получать больше жизней за взятие бонуса, раздавать игрокам разное количество жизней на старте игры и так далее.
				</p>
			</div>
		</p>
		<p>
			<div id="Map" class="tabcontent">
				<h2>Карта RAM</h2>
				<p>
					Создание карты RAM означает нахождение как можно большего количества адресов и добавление на них комментариев через Hex Editor или Debugger с пометкой того, за что отвечает данный адрес.
				</p>
				<p>
					Чем больше адресов ты найдешь и расшифруешь их значение, тем проще тебе будет изучать код, связанный с этими адресами. Все эти комментарии будут отображаться в окне Debugger'а (и в названии окна Hex Editor'а тоже), и даже с поверхностными знаниями инструкций процессора ты примерно поймешь что именно делает найденный участок кода.
				</p>
				<p>
					<img src="1.png">
				</p>
				<p class="tip">
					Код записывает количество #$03 в адрес жизней обоих игроков, а затем проверяет режим игры и обнуляет жизни 2-го игрока, если в опциях предварительно был выбран режим "1 Player".
				</p>
				<p>
					Большое количество расшифрованных адресов также помогает лучше понять как устроена игра и без просмотра ее кода. Когда знаешь внутреннюю механику игры, ты сможешь выбрать лучший из множества способ отредактировать код, учтешь все возможные ситуации и снизишь шансы на появление сопутствующих багов, нежели работая с игрой практически вслепую.
				</p>
			</div>
		</p>
		<p>
			<div id="Search" class="tabcontent">
				<h2>Методы поиска адресов</h2>
				<p>
					Есть 4 основных метода поиска адреса.
				</p>
				<h3>Hex Editor</h3>
				<h4>Наблюдение за адресами</h4>
				<p>
					Достаточно взглянуть на байты в адресах, которые подсвечиваются разными цветами при их изменений. Байты меняются чаще всего тогда, когда в игре что-то происходит. Если ты двигаешься персонажем, то его координата будет меняться, но если персонаж стоит на месте, следовательно изменений ты не увидишь.
				</p>
				<p>
					<img src="https://i.imgur.com/BkozDte.gif"><!--0043-->
				</p>
				<p>
					Поэтому самый обычный поверхностный поиск адресов осуществляется через наблюдение за адресами RAM в окне Hex Editor. При этом очень помогают сохранения игрового процесса "до" и "после" изменений.
				</p>
				<h4>Сравнение сохранений</h4>
				<p>
					Например, если твой персонаж погиб, количество жизней должно уменьшиться на #$01. Загружай по очереди то первое сохранение, то второе, параллельно наблюдая за тем, какие байты в адресах изменили свое значение.
				</p>
				<p>
					<img src="https://i.imgur.com/zUDR3wf.gif"><!--0044-->
				</p>
				<p>
					Таким образом ты довольно быстро локализуешь найдешь адрес, в котором произошло уменьшение на #$01 относительно двух этих сохранений. А если сбросить подсветку байтов скроллингом окна и загружать сохранения на паузе эмулятора, будут подсвечиваться только изменения между этими сохранениями, что еще больше упростит задачу.
				</p>
				<h4>Изменение и заморозка байтов</h4>
				<p>
					Не забывай о том, что ты можешь вручную изменять байты в адресах и замораживать их. Предварительно пользуйся сохранениями, так как заранее не знаешь какие будут последствия.
				</p>
				<p>
					<img src="https://i.imgur.com/3uYlorj.gif"><!--0045-->
				</p>
				<h3>RAM Search</h3>
				<p>
					Инструкция по работе с окном RAM Search будет на главной странице сайта. Это окно позволяет создавать условия, или фильтры, через которые пропускаются байты в адресах и отсекаются лишние.
				</p>
				<p>
					Если примерно представлять как именно могут храниться данные в неком адресе, нужно немного поиграть, параллельно пропуская адреса через особые условия с учетом изменений байта в искомом адресе. По итогу фильтр пройдут лишь малое количество адресов, среди которых не составит труда найти правильный.
				</p>
				<h3>Debugger</h3>
				<p>
					Если у тебя уже есть комментарии на адреса RAM, то при просмотре участка кода можно увидеть и другие адреса, участвующие в работе данной программы.
				</p>
				<p>
					Если ты пока еще не знаешь за что они отвечают, то глядя на уже расшифрованные адреса и учитывая общее назначение программы, у тебя появятся мысли о том, зачем нужны эти незнакомые адреса. А подтвердить свои догадки по адресу ты можешь работая с окном Hex Editor и/или поставив на него брейкпоинты.
				</p>
				<h3>Двоичный поиск</h3>
				<p>
					Универсальный поиск адресов методом копирования данных между двумя сохранениями описан в подразделе этой статьи.
				</p>
			</div>
		</p>
		<script src="https://iromhacker.ru/spoiler.js"></script>
		<script src="https://iromhacker.ru/tab.js"></script>
	</body>
</html>