<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Ромхакинг NES. Поиск RAM адресов</title>
		<meta name="description" content="Базовые методы поиска адреса в оперативной памяти и описание адресов. Basic methods of searching RAM addresses and their description">
		<meta name="keywords" content="">
		<link rel="icon" href="https://iromhacker.ru/favicon.png" type="image/png">
		<link href="https://iromhacker.ru/style.css" rel="stylesheet">
		<script src="https://iromhacker.ru/analytics.js"></script>
	</head>
	<body>
		<h1>Поиск RAM адресов</h1>
		<p>
			<center>
				<a class="return" href="https://iromhacker.ru/nes/ru/index.html">Вернуться на главную страницу</a>
			</center>
		</p>
		<p class="content">
			Содержание
		</p>
		<ul>
			<li>Поиск игровых адресов</li>
			<ul>
				<li><a href="../1-1/index.html">Виды адресов</a></li>
				<li><a href="../1-2/index.html">Двоичный поиск</a></li>
			</ul>
			<li><a href="../2/index.html">Поиск свободных адресов</a></li>
		</ul>
		<h2>Поиск игровых адресов</h2>
		<p class="notice">
			Для ознакомления с разделом требуется базовое знание окон Hex Editor и Debugger, а также инструкций процессора.
		</p>
		<p>
			В RAM (диапазон адресов $0000-$07FF в NES Memory) хранятся динамические данные игрового процесса. Местоположение большинства адресов, в которых хранятся определенные данные, является статическим, то есть они всегда будут находиться по тому же адресу в RAM каждый раз, когда ты запускаешь игру или делаешь Reset.
		</p>
		<p>
			В этом разделе будет рассказано про то, как именно в RAM хранятся некоторые данные, чтобы ты примерно знал что надо искать при просмотре адресов во время игры, а также про различные метода поиска этих адресов.
		</p>
		<h3>Зачем искать адреса</h3>
		<p>
			Чтобы что-то изменить в игре, нужно знать адрес, который отвечает за ту функцию, которую ты хочешь изменить. Зная правильный адрес, ты ставишь на него Read и/или Write брейкпоинт для нахождения связанного с этим адресом кода. 
		</p>
		<p>
			Например, найдя адрес с количеством жизней игрока и поставив на него Write брейкпоинт, ты обнаружишь код, который записывает это начальное количество/изменяет его после смерти игрока.
		</p>
		<p>
			Если поставить Read брейкпоинт, тебе повстречаются программы, которые считывают это количество и что-то с ним делают, наподобие вывода количества жизней на экране или проверки на #$00 для завершения игры.
		</p>
		<p>
			Когда код найден, то с соответствующими знаниями инструкций процессора ты сможешь отредактировать код по своему усмотрению, к примеру получать больше жизней за взятие бонуса, раздавать игрокам разное количество жизней на старте игры и так далее.
		</p>
		<h3>Карта RAM</h3>
		<p>
			Создание карты RAM означает нахождение как можно большего количества адресов и добавление на них комментариев через Hex Editor или Debugger с пометкой того, за что отвечает данный адрес.
		</p>
		<p>
			Чем больше адресов ты найдешь и расшифруешь их значение, тем проще тебе будет изучать код, связанный с этими адресами. Все эти комментарии будут отображаться в окне Debugger'а (и в названии окна Hex Editor'а тоже), и даже с поверхностными знаниями инструкций процессора ты примерно поймешь что именно делает найденный участок кода.
		</p>
		<p>
			<img src="1.png">
		</p>
		<p class="tip">
			Код записывает количество #$03 в адрес жизней обоих игроков, а затем проверяет режим игры и обнуляет жизни 2-го игрока, если в опциях предварительно был выбран режим "1 Player".
		</p>
		<p>
			Большое количество расшифрованных адресов также помогает понять как устроена игра и без просмотра ее кода. Когда знаешь внутреннюю механику игры, ты сможешь выбрать лучший из множества способов отредактировать код, учтешь все возможные ситуации и снизишь шансы на появление сопутствующих багов, нежели работая с игрой практически вслепую.
		</p>
		<h3>Методы поиска адресов</h3>
		<p>
			Выбери опцию, чтобы посмотреть информацию по данному методу поиска.
		</p>
		<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'NES')">NES Memory</td>
					<td class="tabLink" onclick="openTab(event, 'RAM')">RAM Search</td>
					<td class="tabLink" onclick="openTab(event, 'Debugger')">Debugger</td>
					<td class="tabLink" onclick="openTab(event, 'PPU')">PPU Memory</td>
					<td class="tabLink" onclick="openTab(event, 'OAM')">Sprite Memory</td>
				</tr>
			</table>
		</p>
		<p>
			<div id="NES" class="tabcontent">
				<h2>NES Memory</h2>
				<p>
					Базовый поиск сводится к минимизации изменений в других адресах. Чем меньше байтов "шевелится" в данный игровой момент, тем проще искать нужные изменения.
				</p>
				<h3>Наблюдение за адресами</h3>
				<p>
					Достаточно взглянуть на байты в адресах, которые подсвечиваются разными цветами при их изменений. Байты меняются чаще всего тогда, когда в игре что-то происходит. Если ты двигаешься персонажем, то его координата начнет изменяться, но если персонаж стоит на месте, следовательно изменений ты не увидишь.
				</p>
				<p>
					<img src="https://i.imgur.com/BkozDte.gif"><!--0043-->
				</p>
				<p>
					Поэтому самый обычный поверхностный поиск адресов осуществляется через наблюдение за адресами RAM в окне Hex Editor. При этом очень помогают сохранения игрового процесса "до" и "после" изменений.
				</p>
				<h3>Сравнение сохранений</h3>
				<p>
					Например, если твой персонаж погиб, количество жизней должно уменьшиться на #$01. Загружай по очереди то первое сохранение, то второе, параллельно наблюдая за тем, какие байты в адресах изменили свое значение.
				</p>
				<p>
					<img src="https://i.imgur.com/zUDR3wf.gif"><!--0044-->
				</p>
				<p>
					Таким образом ты довольно быстро локализуешь адрес, в котором произошло уменьшение на #$01 относительно двух этих сохранений. А если загружать сохранения на паузе эмулятора, предварительно сбросив подсветку байтов скроллингом окна, будут подсвечиваться исключительно изменения между этими сохранениями, что еще больше упростит задачу.
				</p>
				<h3>Изменение и заморозка байтов</h3>
				<p>
					Не забывай о том, что ты можешь пробовать вручную изменять байты в адресах и замораживать их. Предварительно пользуйся сохранениями, так как заранее не знаешь какие будут последствия.
				</p>
				<p>
					<img src="https://i.imgur.com/3uYlorj.gif"><!--0045-->
				</p>
				<h3>Двоичный поиск</h3>
				<p>
					Универсальный поиск адресов методом копирования данных между двумя сохранениями описан в отдельной статье этого раздела.
				</p>
			</div>
		</p>
		<p>
			<div id="RAM" class="tabcontent">
				<h2>RAM Search</h2>
				<p>
					Инструкция по работе с окном RAM Search будет на главной странице сайта. Это окно позволяет создавать условия, или фильтры, через которые пропускаются байты в адресах и отсекаются лишние.
				</p>
				<p>
					Если примерно представлять как именно могут храниться и изменяться данные в неком адресе, нужно немного поиграть, параллельно пропуская адреса через особые условия с учетом изменений байта в искомом адресе. По итогу фильтр пройдут лишь малое количество адресов, среди которых не составит труда найти правильный.
				</p>
				<p>
					Чем больше у тебя опыта, тем лучше ты сможешь выставлять условия. Иногда достаточно лишь уверенности в том, что эти байты должны измениться в определенный момент, и фильтровать по данным, которые "не изменились".
				</p>
			</div>
		</p>
		<p>
			<div id="Debugger" class="tabcontent">
				<h2>Debugger</h2>
				<p>
					Если у тебя уже есть комментарии на адреса RAM, то при просмотре участка кода можно увидеть и другие адреса, участвующие в работе данной программы.
				</p>
				<p>
					Если ты пока еще не знаешь за что они отвечают, то глядя на уже расшифрованные адреса и учитывая общее назначение программы, у тебя появятся мысли о том, зачем нужны эти незнакомые адреса. А подтвердить свои догадки по адресу ты можешь работая с окном Hex Editor и/или поставив на него брейкпоинты.
				</p>
			</div>
		</p>
		<p>
			<div id="PPU" class="tabcontent">
				<h2>PPU Memory</h2>
				<p>
					Если игровые данные из RAM адресов выводятся на экране, например количество очков, такие адреса можно найти через видеопамять, выяснив откуда берутся значения.
				</p>
				<p>
					Чаще всего байт из оригинального адреса будет передаваться через адреса-посредники, участвующих в работе программы вывода графики. Потребуется проследить цепочку передачи байта между несколькими адресами до оригинального адреса, а для этого нужен опыт работы с Debugger'ом и знание инструкций процессора.
				</p>
				<p>
					<iframe class="youtube" width="560" height="315" src="https://www.youtube.com/embed/cyiV4ecp9kI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				</p>
			</div>
		</p>
		<p>
			<div id="OAM" class="tabcontent">
				<h2>Sprite Memory</h2>
				<p class="tip">
					Под Sprite Memory подразумевается не OAM Memory, а та область из NES Memory, которая копируется в OAM Memory.
				</p>
				<p>
					Некоторые данные могут выводиться на экране с помощью спрайтов, а не заднего фона. Поиск по принципу похож на поиск адресов через PPU Memory - надо найти адреса в памяти спрайтов, в которые записываются нужные тайлы для спрайтов, отображенных на экране, поставить на них Write брейкпоинты и отследить цепочку записи.
				</p>
				<p>
					Этот способ поиска несколько сложнее, чем поиск по PPU Memory, поскольку труднее локализовать нужный адрес в памяти спрайтов, чтобы затем найти откуда в него пишутся значения. Здесь тоже требуется опыт работы с Debugger'ом и знание инструкций процессора.
				</p>
				<p>
					<iframe class="youtube" width="560" height="315" src="https://www.youtube.com/embed/JxUGp-zj91Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				</p>
			</div>
		</p>
		<script src="https://iromhacker.ru/spoiler.js"></script>
		<script src="https://iromhacker.ru/tab.js"></script>
	</body>
</html>