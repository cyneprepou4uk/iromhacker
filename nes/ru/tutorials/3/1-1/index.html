<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Ромхакинг NES. Основные виды RAM адресов</title>
		<meta name="description" content="Особенности возможных игровых адресов и методы их поиска. A peculiarity of possible RAM addresses and how to find them">
		<meta name="keywords" content="">
		<link rel="icon" href="https://iromhacker.ru/favicon.png" type="image/png">
		<link href="https://iromhacker.ru/style.css" rel="stylesheet">
		<script src="https://iromhacker.ru/analytics.js"></script>
	</head>
	<body>
		<h1>Виды адресов</h1>
		<p>
			<center>
				<a class="return" href="https://iromhacker.ru/nes/ru/index.html">Вернуться на главную страницу</a>
			</center>
		</p>
		<p class="content">
			Содержание
		</p>
		<ul>
			<li><a href="../1/index.html">Поиск игровых адресов</a></li>
			<ul>
				<li>Виды адресов</li>
				<li>Двоичный поиск</li>
			</ul>
			<li>Поиск свободных адресов</li>
		</ul>
		<h2>Виды адресов</h2>
		<p>
			Динамические данные могут храниться в различном формате. Некоторые форматы выглядят в RAM достаточно очевидно, например численное количество чего-либо. Некоторые могут быть непонятны на первый взгляд, вроде указателей или порядкового номера объекта.
		</p>
		<p>
			Способ хранения данных, а также то, какие именно адреса существуют, зависят от самой игры. Если ты достаточно хорошо знаком с игрой в качестве рядового игрока, а не ромхакера, тебе будет проще опознать эти адреса. С незнакомыми играми работать несколько сложнее, но в целом это не критично.
		</p>
		<p>
			Все случаи описать здесь не получится, будет рассказано только про самые распространенные. Выбери опцию из списка, чтобы посмотреть информацию по этому виду адресов.
		</p>
		<p class="tip">
			Раздел еще в разработке, ссылки будут добавлены постепенно.
		</p>
		<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Lives')">Жизни</td>
					<td class="tabLink" onclick="openTab(event, 'Timers')">Таймеры</td>
					<td class="tabLink" onclick="openTab(event, 'Counters')">Счетчики</td>
					<td class="tabLink" onclick="openTab(event, 'Coordinates')">Координаты</td>
					<td class="tabLink" onclick="openTab(event, 'Speed')">Скорость</td>
					<td class="tabLink" onclick="openTab(event, 'Buttons')">Кнопки</td>
					<td class="tabLink" onclick="openTab(event, 'Points')">Очки</td>
					<td>Рандом</td>
				</tr>
				<tr>
					<td>Индикаторы</td>
					<td>Параметры</td>
					<td>Музыка</td>
					<td>Графика</td>
					<td>Номера</td>
					<td>Временные</td>
					<td>Свободные</td>
					<td>Прочие</td>
				</tr>
			</table>
		</p>
		<!--<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Lives')">Жизни</td>
					<td class="tabLink" onclick="openTab(event, 'Timers')">Таймеры</td>
					<td class="tabLink" onclick="openTab(event, 'Counters')">Счетчики</td>
					<td class="tabLink" onclick="openTab(event, 'Coordinates')">Координаты</td>
					<td class="tabLink" onclick="openTab(event, 'Buttons')">Кнопки</td>
					<td class="tabLink" onclick="openTab(event, 'Points')">Очки</td>
					<td class="tabLink" onclick="openTab(event, 'Random')">Рандом</td>
					<td class="tabLink" onclick="openTab(event, 'Indicators')">Индикаторы</td>
				</tr>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Stats')">Параметры</td>
					<td class="tabLink" onclick="openTab(event, 'Music')">Музыка</td>
					<td class="tabLink" onclick="openTab(event, 'Graphics')">Графика</td>
					<td class="tabLink" onclick="openTab(event, 'ID')">Номера</td>
					<td class="tabLink" onclick="openTab(event, 'Temporary')">Временные</td>
					<td class="tabLink" onclick="openTab(event, 'Free')">Свободные</td>
					<td colspan="2" class="tabLink" onclick="openTab(event, 'Other')">Прочие</td>
				</tr>
			</table>
		</p>-->
		<p>
			<div id="Lives" class="tabcontent">
				<h2>Жизни</h2>
				<p>
					К этой категории адресов относятся не только жизни, но еще HP (Health Points - очки здоровья) и Continue (количество продолжений после Game Over).
				</p>
				<p>
					Это одни из самых популярных адресов, которые ищут новички, так как на них делаются первые тестовые хаки, связанные с изменением начальных значений и бесконечностью данных игровых параметров.
				</p>
				<h3>Оообенности</h3>
				<p>
					Количество жизней хранится в одном адресе. Встречаются 2 распространенных случая, в зависимости от кода игры на проверку Game Over и отображения жизней на экране.
				</p>
				<p>
					В первом случае количество жизней в адресе равно тому, что выводится на экране, то есть 3 жизни = #$03. Во втором случае количество жизней будет меньше на #$01, то есть 3 жизни = #$02.
				</p>
				<p>
					Персонаж гарантированно имеет некое количество жизней лишь тогда, когда он получает способность умирать и продолжать игру после смерти. Если играть без смертей, а также не получать дополнительные жизни разничными бонусами, количество жизней в адресе останется без изменений.
				</p>
				<p>
					Персонаж гарантированно теряет жизнь лишь тогда, когда тот полностью завершит анимацию смерти, чтобы он воскрес/уровень начался заново, так как в момент смерти количество жизней может сразу не измениться. Чаще всего значение в адресе будет уменьшено.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Mortal Kombat Trilogy - MK5 (вероятно и в других тоже) байт в адресе с HP может увеличиваться при получении урона, а не уменьшаться. Персонаж умрет, когда это количество достигнет определенного значения.
				</p>
				<p>
					В игре Darkwing Duck жизни хранятся сразу в двух адресах, а количество HP сразу в четырех, причем байты в этих адресах являются номерами тайлов. Это сделано для удобства отображения их количества на экране и во время паузы.
				</p>
				<h3>Методы поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Сравниваешь 2 сохранения, в которых количество жизней отличается на #$01. Также можно попробовать воспользоваться поиском предполагаемого байта и проверить все найденные адреса.
				</p>
				<p>
					В предполагаемом найденном адресе увеличиваешь количество и пробуешь умирать, проверяешь чтобы отображаемых жизней стало больше. Если количество жизней выводится на экране, возможно ты сразу увидишь изменения числа.
				</p>
				<p>
					Заморозив байт в адресе с жизнями, твой персонаж должен перестать терять жизни после смерти.
				</p>
				<p class="tip">
					Для безопасности лучше замораживать байт #$02 и выше, иначе в некоторых случаях все равно может случиться Game Over. Это зависит от особенности кода игры, который проверяет на Game Over после уменьшения жизней.
				</p>
				<h4>RAM Search</h4>
				<p>
					Отсеиваешь адреса, в которых записан байт #$00, через Not Equal To + Specific Value 00.
				</p>
				<p>
					Немного поиграв и не умерев, отсеиваешь адреса без изменений через Equal To + Previous Value.
				</p>
				<p>
					Затем умираешь, дожидаешься воскрешения и ставишь условие на Less Than/Not Equal To/Different By 01 + Previous Value для проверки на изменения.
				</p>
				<p class="tip">
					Или можно сразу поставить условие на определенное количество жизней через Equal To + Specific Value xx, но ты можешь не угадать с байтом, испортив себе весь подготовительный поиск.
				</p>
			</div>
		</p>
		<p>
			<div id="Timers" class="tabcontent">
				<h2>Таймеры</h2>
				<p>
					Под таймером подразумевается отсчет чего-либо до завершения действия этого события. К этой категории относятся таймер неуязвимости, действия бонусов, внутриигровое время и так далее. То есть длительность того, таймер чего изменяется каждый кадр (или каждый внутриигровой кадр).
				</p>
				<h3>Оообенности</h3>
				<p>
					Поскольку таймер это отсчет до завершения, скорее всего байт в адресе будет ежекадрово уменьшаться на #$01. В редких случаях будет увеличиваться на #$01.
				</p>
				<p>
					Если таймер в данный момент не используется, например когда у персонажа отсутствует неуязвимость, в адресе должно быть записано #$00.
				</p>
				<h4>Большие таймеры</h4>
				<p>
					Один адрес может хранить значение от 0 до 255. Если таймер длится дольше 255 кадров, он будет использовать сразу 2 адреса, которые в сумме создают 16-битное число, увеличивая лимит до 65535.
				</p>
				<p>
					Старший байт такого счетчика будет уменьшаться только тогда, когда полностью уменьшится младший байт счетчика. Вот пример счетчика, который считает от 600 до 0, значение уменьшается ежекадрово на протяжении 10-ти кадров.
				</p>
				<p>
					<img src="https://i.imgur.com/qvhHblH.gif"><!--0046-->
				</p>
				<p class="tip">
					Эти 2 адреса могут находиться где угодно, не обязательно по соседству друг с другом.
				</p>
				<h4>Таймер времени</h4>
				<p>
					Чтобы сэмулировать точные реальные часы, требуются адреса с терциями (терция = 1/60 секунды), секундами, минутами и, возможно, часами.
				</p>
				<p>
					Терции, секунды и минуты должны хранить байт не более #$3C (60). В зависимости от кода, это может быть байт #$3D. Минуты уменьшаются/увеличиваются после секунд, а секунды после терций.
				</p>
				<p>
					<img src="https://i.imgur.com/wlFlbAB.gif"><!--0048-->
				</p>
				<p>
					Адрес с терциями существует практически у таймера, который отображается на экране. Если игра не пытается создать точные часы, байт в нем будет меньше, чем #$3C.
				</p>
				<h4>Счетчик кадров</h4>
				<p>
					Этот тип адреса больше подходит к таймерам, чем счетчикам, так как его значение постоянно ежекадрово увеличивается на #$01, и его можно спутать с таймером.
				</p>
				<p>
					Счетчик кадров существует практически во всех играх. Обычно он служит для вычисления рандома. А факт того, что он увеличивается ежекадрово, позволяет легко прикручивать свои собственные ежекадровые подпрограммы к тому месту в коде, где выполняется инструкция его увеличения.
				</p>
				<h4>Особые случаи</h4>
				<p>
					В игре Battle City счетчик кадров участвует в паре с адресами таймеров бонусов для вычисления их длительности. Бонусы длятся по 10/20 секунд в небольшой погрешностью, так как при взятии бонуса счетчик кадров не изменяется.
				</p>
				<p>
					В игре Super Mario Bros. единицы, десятки и сотни у числа таймера хранятся в трех отдельных соседних адресах в формате BCD (binary-coded decimal). Подробнее про этот формат прочитаешь в подразделе с адресами очков.
				</p>
				<h3>Метод поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Побдираешь бонус/получаешь урон, затем просматриваешь адреса RAM в поисках чего-либо, что хоть как-то напоминает счетчик. Ориентируйся по самой игре, чтобы таймер в адресе и действие бонуса/неуязвимости в игре заканчивались одновременно.
				</p>
				<p>
					Адрес найден правильно, если при заморозке байта таймер неуязвимости/бонуса станет длиться бесконечно. Счетчик времени полностью остановится лишь в случае заморозки адреса с терциями.
				</p>
				<p>
					Если записать какой-то байт в таймер действия бонуса/неуязвимости, это может активировать данную игровую функцию. В противном случае вероятно существует еще какой-то адрес, в котором хранится текущее "состояние" игрока, например факт активированной неуязвимости.
				</p>
				<h4>RAM Search</h4>
				<p>
					Пока таймер деактивирован, отсеиваешь адреса, в которых записаны байты кроме #$00, через Equal To + Specific Value 00.
				</p>
				<p>
					Подобрав бонус/получив урон, отсеиваешь адреса, в которых записан байт #$00, через Not Equal To + Specific Value 00.
				</p>
				<h4>Debugger</h4>
				<p>
					Если по каким-то причинам ты нашел лишь один из адресов таймера, но не можешь найти остальные, поставь Write брейкпоинт на найденный адрес. Ты обнаружишь программу, где происходит вычисление общего таймера, в которой ты найдешь и другие адреса таймера, участвующие в работе этой программы.
				</p>
				<p>
					<img src="3.png">
				</p>
			</div>
		</p>
		<p>
			<div id="Counters" class="tabcontent">
				<h2>Счетчики</h2>
				<p>
					Под счетчиком подразумевается подсчитывание количества чего-либо. Например, количество собранных бонусов, количество оставшихся врагов на уровне.
				</p>
				<p>
					В отличие от таймеров, счетчики изменяются не ежекадрово, а лишь при особом игровом событии, возникновение которого нужно подсчитать.
				</p>
				<h3>Оообенности</h3>
				<p>
					В зависимости от предназначения счетчика, он может либо увеличиваться на #$01, если нужно посчитать сколько раз было что-то сделано, или уменьшаться, например нужно убить столько-то врагов для завершения уровня.
				</p>
				<p class="tip">
					Счетчики, которые по логике должны уменьшаться, в действительности вполне могут и увеличиваться, а затем проверяться на определенное число.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Bugs Bunny Crazy Castle сбор всех морковок для завершения уровня проверяется не по счетчику морковок, а факту подбора каждой отдельной морковки, для каждой из которых выделен отдельный адрес.
				</p>
				<p>
					В игре Battle City для количества врагов выделено сразу 2 адреса. Один из них служит для подсчета количества врагов, которых нужно уничтожить на уровне. Во втором хранится количество врагов, которые еще не появились.
				</p>
				<h3>Метод поиска</h3>
				<p>
					Аналогичен поиску адресов с жизнями. А также если записать #$00 в адрес счетчика врагов, вполне возможно уровень сразу будет завершен.
				</p>
			</div>
		</p>
		<p>
			<div id="Coordinates" class="tabcontent">
				<h2>Координаты</h2>
				<p>
					Координаты служат в основном для отображения объектов на экране. Всегда имеются главные координаты объекта, но также могут существовать и другие, которые относятся, например, к отображению объекта на миникарте или различным индикаторам объекта, вроде циферки над ним.
				</p>
				<p>
					<img src="1.png">
				</p>
				<p>
					Технически любой игровой объект размером 1 пиксель. При помощи кода вокруг него рисуется графика, а еще создается некая область, при соприкосновении с которой другие объекты могут наносить ему урон (хитбоксы), и/или наоборот, получать урон от этого объекта (хертбоксы).
				</p>
				<h3>Особенности</h3>
				<p>
					Начальная позиция (0,0), откуда начинается отсчет координат, чаще всего расположена в верхнем левом уголу экрана, относительно которой изменяется координата во время движения объекта.
				</p>
				<p class="tip">
					У игр региона NTSC не отображаются верхние и нижние 8 пикселей экрана, что можно изменить в настройках эмулятора.
				</p>
				<p>
					У координат может существовать дробная часть пикселя, подробности читай в подразделе с адресами скорости.
				</p>
				<p>
					Адреса с координатами для всех игровых объектов скорее всего будут находиться где-то по соседству.
				</p>
				<h4>Главные адреса координат</h4>
				<p>
					Главными адресами считаются те, от которых зависят все остальные адреса с координатами. Изменяя главные адреса, ты будешь влиять и на изменение зависимых адресов.
				</p>
				<p>
					Основными осями координат являются X (горизонталь) и Y (вертикаль). В некоторых играх может существовать третья ось координат - Z (высота).
				</p>
				<p>
					Если уровень по размеру больше, чем 256 пикселей, и/или когда объект может уйти за экран, но в действительности не удаляется из игры и его можно успеть догнать, будет существовать старший байт адреса координты.
				</p>
				<p>
					<img src="https://i.imgur.com/fkTsj4E.gif"><!--0049-->
				</p>
				<h4>Камера</h4>
				<p>
					Если уровень может скроллиться в какую-либо сторону, ты можешь найти адреса со старшими и младшими координатами позиции камеры. Адреса будут меняться в том случае, если движение персонажа приводит к смещению камеры.
				</p>
				<p>
					Координаты камеры скорее всего будут зависеть от главных координат персонажа, а не наоборот.
				</p>
				<p>
					Если предполагается, что объект всегда находится на экране, то при наличии адресов координат камеры возможно не будет существовать адрес со старшим байтом координаты объекта, так как в нем нет необходимости.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Teenage Mutant Ninja Turtles III - The Manhattan Project адреса с хитбоксами находятся в отдельных адресах, а не вычисляются относительно основных координат.
				</p>
				<p>
					В игре Super Mario Bros. младший байт координаты Y = #$00 не в самом верху экрана, а под статусбаром (где очки и таймер). Находясь под статусбаром, старший байт координаты Y = #$01.
				</p>
				<h3>Метод поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Нужно двигаться персонажем и наблюдать за адресами, которые напоминают его координаты.
				</p>
				<p>
					Если изменять байты в главных адресах координат, объект должен телепортироваться. Последствия телепорта внутрь стены/пола/платформы непредсказуемы. Если это не главный адрес, байт скорее всего будет сразу же перезаписан игрой.
				</p>
				<p>
					Если заморозить младший байт, объект должен перестать иметь возможность двигаться по соответствующей оси. Если заморозить старший байт, объект сможет продолжать двигаться, но при попытке увеличить старший байт координаты объект будет телепортирован в другую часть экрана.
				</p>
				<h4>RAM Search</h4>
				<p>
					Пока персонаж стоит на месте, отсеивай адреса без изменений через Equal To + Previous Value. Также если ты предполагаешь, что твои координаты сейчас не равны #$00, дополнительно фильтруй через Not Equal To + Specific Value 00.
				</p>
				<p>
					Затем сдвинься в сторону по X и Y и остановись. Разово исключи изменившиеся адреса через Not Equal To + Previous Value. Переключись на Equal To + Previous Value и продолжай отсев. При необходимости повтори движение в сторону.
				</p>
			</div>
		</p>
		<p>
			<div id="Speed" class="tabcontent">
				<h2>Скорость</h2>
				<p>
					Скорость - это байты, которые будут складываться/вычитаться с координатами объектов, создавая эффект их передвижения. Чем выше скорость, тем быстрее объект будет смещаться в ту или иную сторону по соответствующей оси.
				</p>
				<h3>Особенности</h3>
				<p>
					Если объект может динамически менять скорость движения, например при ходьбе/беге, скорость скорее всего будет храниться в RAM, и изменяться одновременно с изменениями координат объекта, пока объект разгоняется.
				</p>
				<p>
					Адреса скоростей, как и координаты, скорее всего находятся где-то по соседству для всех объектов сразу.
				</p>
				<p>
					Для движения вправо используются положительные байты, а для движения влево - отрицательные. Сторона движения обычно определяется адресом, в котором хранится то, куда повернут объект, и скорее всего в нем будут байты #$00/#$80.
				</p>
				<p>
					Чаще всего для смещения объекта в любую сторону существует одна общая программа, которая складывает значения координат со скоростью. Если координата складывается с положительным байтом, она будет увеличиваться, а если с отрицательным, то уменьшаться.
				</p>
				<h4>Точная скорость</h4>
				<p>
					1 целый пиксель - довольно большая единица измерения движения, с учетом того, что объекты со скоростью 1 и 2 пикселя за кадр будут слишком быстрые/медленные относительно друг друга. Для более точного измерения скорости вводится адрес, в котором хранится дробная часть пикселя.
				</p>
				<p>
					Отобразить движение на дробную часть пикселя игра не сможет, однако на длительном промежутке разница в скорости станет заметна. Чем больше дробная часть, тем быстрее будет двигаться объект.
				</p>
				<p>
					<img src="https://i.imgur.com/2yJtMO8.gif"><!--0050-->
				</p>
				<p>
					Если существует адрес скорости с дробной частью пикселя, тогда будет существовать такой же адрес и у координаты, поскольку эту дробную часть пикселя потребуется сложить с такой же дробной частью, а при получении целого пикселя добавить его к целой части коордитаны.
				</p>
				<h4>Гравитация</h4>
				<p>
					Если в игре существует плавная гравитация, почти наверняка можно найти адреса с дробной частью пикселя для осей Y/Z.
				</p>
				<p>
					В начале прыжка записывается положительная скорость смещения, благодаря которой персонаж может подпрыгнуть. Эта скорость будет постепенно уменьшаться и превращаться в отрицательную, что создает эффект гравитации, когда персонаж достигает максимальной высоты и начинает падать.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Battle City скорость разных типов танков не хранится в RAM. Вместо этого игра проверяет номер кадра и решает, следует ли ей изменить их координаты во время движения, что позволяет создавать различные скорости для разных танков.
				</p>
				<p>
					В игре Super Mario Bros. скорость движения по X хранится в одном-единственном адресе, который на мой взгляд является таймером разгона персонажа, нежели скоростью. В зависимости от величины таймера код игры вычисляет скорость смещения координаты X.
				</p>
				<h3>Метод поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Нужно двигаться персонажем и наблюдать за адресами, которые изменяются вместе с его координатами. Значение в адресе с целым пикселем должно быть примерно равно тому значению, на которое ежекадрово изменяется координата.
				</p>
				<p>
					Заморозив байт больше #$00 в адресе целого пикселя, объект может начать двигаться по соответствующей оси без удержания кнопки движения. Если ты можешь управлять этим объектом в игре, скорее всего он не будет воспроизводить анимацию движения.
				</p>
				<p>
					Последствия прохождения сквозь стену/пол/платформу непредсказуемы. Возможно потребуется увеличить байт, если объект упирается в стену и отказывается проходить сквозь нее, так как код игры выталкивает объект оттуда.
				</p>
				<p>
					Заморозка дробной части пикселя вряд ли заставит объект двигаться, если в данный момент целый пиксель = #$00. Игра может экономить ресурсы процессора, игнорируя проверку дробной части, считая, что в этом случае объект не двигается.
				</p>
				<p>
					Если во время прыжка заморозить положительный байт в адресе со скоростью смещения Y/Z, это заставит объект постоянно набирать высоту и не падать.
				</p>
				<h4>Debugger</h4>
				<p>
					Поставь Write брейкпоинт на адрес координат во время движения объекта, и наверняка ты сразу обнаружишь с какими адресами складываются его координаты. Почти гарантированно здесь будет код, добавляющий #$00 к старшему байту координаты без предварительной очистки флага C (для учета остатка при сложении младших байтов).
				</p>
				<p>
					<img src="2.png">
				</p>
				<p class="tip">
					Начало диапазонов адресов скоростей объектов для оси Y - $0404 (дробная часть) и $0412 (целая часть).
				</p>
			</div>
		</p>
		<p>
			<div id="Buttons" class="tabcontent">
				<h2>Кнопки</h2>
				<p>
					Чтобы твой персонаж мог двигаться, прыгать, стрелять и так далее, игра считывает регистры джойстиков $4016 и $4017, проверяет нажатие каждой кнопки, и результат выводится в адресе RAM.
				</p>
				<p>
					Эти адреса чаще всего находятся в нулевой странице ($0000-$00FF) для экономии ресурсов процессора, так игра скорее всего ежекадрово записывает кнопки в адрес, а затем считывает их.
				</p>
				<h3>Особенности</h3>
				<p>
					В играх выделено минимум по 2 основных адреса для кнопок каждого игрока. Даже если в игре не предусмотрено управление двумя игроками, все равно вероятно в RAM будут выделены адреса для 2-го игрока, в которых отобразятся нажатия со 2-го джойстика.
				</p>
				<p>
					Один адрес (hold) хранит кнопки, которые ты держишь и не отпускаешь, он чаще всего служит для передвижения игрока. Также он может проверяться для высоты прыжка, пока кнопка прыжка все еще удержана.
				</p>
				<p>
					Второй адрес (press) отображает одноразовое нажатие кнопки в течение 1 кадра, после чего нажатие пропадает из адреса даже при удержании кнопки. Он обычно служит для действий, которым требуется одноразовое нажатие кнопки, а не ее удержание, например для стрельбы или выставления игровой паузы.
				</p>
				<p>
					Скорее всего эти адреса находятся по соседству друг с другом, вместе с адресами других игроков. Если игра рассчитана на 4-х игроков, для всех них будут выделены адреса.
				</p>
				<h4>Байты кнопок</h4>
				<p>
					Существуют 2 вида хранения кнопок в адресе. Они отличаются из-за инструкции, которая вращает биты в байте адреса с кнопками. Чаще всего используется инструкция <text class="opcode">ROL</text>. Второй случай с <text class="opcode">ROR</text> встречается реже.
				</p>
				<p>
					<table border=1 cellspacing=1 cellpadding=5>
						<tr>
							<td>Байт</td>
							<td>ROL</td>
							<td>ROR</td>
						</tr>
						<tr>
							<td>01</td>
							<td>Right</td>
							<td>A</td>
						</tr>
						<tr>
							<td>02</td>
							<td>Left</td>
							<td>B</td>
						</tr>
						<tr>
							<td>04</td>
							<td>Down</td>
							<td>Select</td>
						</tr>
						<tr>
							<td>08</td>
							<td>Up</td>
							<td>Start</td>
						</tr>
						<tr>
							<td>10</td>
							<td>Start</td>
							<td>Up</td>
						</tr>
						<tr>
							<td>20</td>
							<td>Select</td>
							<td>Down</td>
						</tr>
						<tr>
							<td>40</td>
							<td>B</td>
							<td>Left</td>
						</tr>
						<tr>
							<td>80</td>
							<td>A</td>
							<td>Right</td>
						</tr>
					</table>
				</p>
				<p>
					Удерживая несколько кнопок одновременно, в основном адресе, где хранятся удержанные кнопки, будет находиться байт, являющийся суммой байтов соответствующих удержанных кнопок. Если ничего не нажато, будет байт #$00.
				</p>
				<p>
					<img src="https://i.imgur.com/qid8OEa.gif"><!--0051-->
				</p>
				<p class="tip">
					Скорость эмулятора замедлена в 8 раз для большей наглядности адреса с одноразовым нажатием кнопки.
				</p>
				<h4>Второстепенные адреса</h4>
				<p>
					Кроме основных адресов кнопок могут быть выделены и другие дополнительные адреса. Некоторые игры хранят в них, например, только кнопку A или B, или обе этих кнопки, или только кнопки движения.
				</p>
				<p>
					Причина этого кроется в игровых действиях, которые может выполнять игрок. Например, заряжать оружие во время удержания кнопки и выстреливать усиленным зарядом после ее отпускания. Или одновременное нажатие кнопок A + B для прыжка, когда по отдельности эти кнопки к прыжку не относятся.
				</p>
				<h4>Искусственный интелект</h4>
				<p>
					Если в игре есть возможность играть против компьютера, или если в игре предусмотрен демо-режим, в котором компьютер управляет игроком самостоятельно, возможно код игры записывает нужные байты по основным адресам кнопок.
				</p>
				<p>
					В таком случае код игры прочитает кнопки и выполнит соответствующее действие, не зависимо от того, игрок это или компьютер. Но такой способ управления компьютером существует не во всех играх.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Super Mario Bros. адреса с кнопками не находятся в нулевой странице RAM. Каждому игроку выделено по 2 адреса, которые расположены довольно далеко друг от друга. Они оба хранят удержание кнопок, однако в первом адресе кнопки Select и Start хранятся как одноразовые.
				</p>
				<h3>Метод поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Нажимай разные кнопки и проверяй адреса нулевой страницы. Желательно нажимать кнопки и на втором джойстике тоже.
				</p>
				<p>
					Без паузы эмулятора вряд ли получится записать или заморозить какой-то байт в эти адреса. Заморозив байт кнопки движения в основном адресе с удержанными кнопками, ты заставишь игрока двигаться без остановки. А заморозив байт кнопки стрельбы в адресе с одноразовыми кнопками, игрок будет постоянно стрелять.
				</p>
				<p>
					Один из двух основных адресов для игрока является главным (с точки зрения кода). Если в нем заморозить байт #$00, то при нажатии кнопок на джойстике они не будут отображаться в другом адресе, так как этот второй адрес будет зависеть от главного.
				</p>
				<p>
					Заморозка байта #$00 позволяет выяснить какой из двух адресов отвечает за определенное игровое действие, так как заморозив байт, это действие больше нельзя будет выполнить в игре.
				</p>
				<h4>Debugger</h4>
				<p>
					Если ты не смог найти адреса с кнопками, поставь Write брейкпоинт на регистр $4016. В найденной программе поищи адреса, куда будут записаны значения по итогу вычисления программы. Конец программы обычно выглядит примерно так, тут можно найти инструкции <text class="opcode">EOR</text> и <text class="opcode">AND</text>.
				</p>
				<p>
					<img src="4.png">
				</p>
			</div>
		</p>
		<p>
			<div id="Points" class="tabcontent">
				<h2>Очки</h2>
				<p>
					Очки обычно выводятся в статусбаре или между уровнями. На экране отображается количество очков, которые набрал игрок за убийство врагов/подбор бонусов/прохождение уровня.
				</p>
				<p>
					Некоторые игры начисляют игроку дополнительные жизни при достижении определенного количества очков.
				</p>
				<h3>Особенности</h3>
				<p>
					Для очков может быть выделено довольно много адресов, чаще всего в нулевой странице RAM ($0000-$00FF), и скорее всего по соседству друг с другом. Если игра рассчитана на 2-х игроков, и они набирают очки по отдельности друг от друга, то на каждого выделено определенное количество адресов. 
				</p>
				<h4>BCD</h4>
				<p>
					Формат хранения данных binary-coded decimal (двоично-десятичный код) позволяет хранить большие числа, которые очень удобно отображать на экране.
				</p>
				<p>
					Каждый адрес является разрядом десятичного числа и хранит в себе байт от #$00 до #$09, означающих цифры 0-9. При наборе очков код выполняет все необходимые арифметичские вычисления, чтобы удержать байт в этом диапазоне, а остаток вычисления добавляет к старшим разрядам числа.
				</p>
				<p>
					<img src="https://i.imgur.com/g5lHu8f.gif"><!--0052-->
				</p>
				<p>
					Некоторые игры могут добавлять к числу дополнительный байт с номером тайла. Например, если тайл цифры 0 это байт #$30, очки могут выглядеть как #$30-#$39, а не #$00-#$09.
				</p>
				<h4>Десятки и единицы</h4>
				<p>
					Скорее всего в игре не существует адресов для этих очков, что позволяет экономить место в RAM. Вместо этого технически ты набираешь 1 очко вместо 100, а лишние 2 нуля просто выводятся на экране как графика.
				</p>
				<h4>Hi-Score</h4>
				<p>
					Если в игре существует рекорд очков, и для него выделены отдельные адреса, и обычно туда изначально записано некое число, например 20.000 очков, Когда игрок превышает рекорд и продолжает играть, байты в адресх с рекордом могут дублировать байты в адресах очков игрока.
				</p>
				<p>
					Если игра не обнуляет адреса RAM после запуска игры, либо после Soft Reset не обнуляет страницу адресов, в которых находятся адреса с очками, это позволяет игре сохранять Hi-Score.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Battle City выделены адреса для десятков и единиц, несмотря на то, что нельзя набрать меньше 100 очков за раз. Записав байты в эти адреса, числа отобразятся во время отображения очков при завершении уровня.
				</p>
				<p>
					Также существует адрес, где хранятся миллионы очков, однако его можно увидеть лишь после Game Over, когда на экране показывается Hi-Score.
				</p>
				<h3>Метод поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Попробовать пробить по поиску байты, которые предположительно отвечают за текущее количество очков. Например, если в данный момент у тебя 12.300 очков, нужно в поисковый запрос ввести байты 01 02 03. Если результатов не найдено, открой PPU Viewer, выясни номер тайла цифр и увеличь искомые байты на соответствующее значение.
				</p>
				<p>
					Если это не помогает, то нужно убивать врагов, делать сохранения и сравнивать их. В предполагаемых адресах изменять байты в пределах формата BCD, пробовать убивать врагов и смотреть как вычисляются байты в соседних адресах при наборе очков.
				</p>
			</div>
		</p>
		<p>
			<div id="Random" class="tabcontent">
				<h2>Рандом</h2>
			</div>
		</p>
		<p>
			<div id="Indicators" class="tabcontent">
				<h2>Индикаторы</h2>
				<p>
					Одноразовый набор 20.000 очков для получения +1 жизни.
				</p>
			</div>
		</p>
		<p>
			<div id="Stats" class="tabcontent">
				<h2>Параметры</h2>
			</div>
		</p>
		<p>
			<div id="Music" class="tabcontent">
				<h2>Музыка</h2>
			</div>
		</p>
		<p>
			<div id="Graphics" class="tabcontent">
				<h2>Графика</h2>
				<p>
					К этой категории относится адреса, используемые в программах вывода графики на экран. Это касается отрисовка заднего фона и изменение палитры.
				</p>
			</div>
		</p>
		<p>
			<div id="ID" class="tabcontent">
				<h2>Номера</h2>
			</div>
		</p>
		<p>
			<div id="Temporary" class="tabcontent">
				<h2>Временные</h2>
				<p>
					Эти адреса внешне напоминают адреса с рандомом
				</p>
			</div>
		</p>
		<p>
			<div id="Free" class="tabcontent">
				<h2>Свободные</h2>
			</div>
		</p>
		<p>
			<div id="Other" class="tabcontent">
				<h2>Прочие</h2>
			</div>
		</p>
		<script src="https://iromhacker.ru/spoiler.js"></script>
		<script src="https://iromhacker.ru/tab.js"></script>
	</body>
</html>