<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Ромхакинг NES. Основные виды RAM адресов</title>
		<meta name="description" content="Особенности возможных игровых адресов и методы их поиска. A peculiarity of possible RAM addresses and how to find them">
		<meta name="keywords" content="">
		<link rel="icon" href="https://iromhacker.ru/favicon.png" type="image/png">
		<link href="https://iromhacker.ru/style.css" rel="stylesheet">
		<script src="https://iromhacker.ru/analytics.js"></script>
	</head>
	<body>
		<h1>Виды адресов</h1>
		<p>
			<center>
				<a class="return" href="https://iromhacker.ru/nes/ru/index.html">Вернуться на главную страницу</a>
			</center>
		</p>
		<p class="content">
			Содержание
		</p>
		<ul>
			<li><a href="../1/index.html">Поиск игровых адресов</a></li>
			<ul>
				<li>Виды адресов</li>
				<li>Двоичный поиск</li>
			</ul>
			<li>Поиск свободных адресов</li>
		</ul>
		<h2>Виды адресов</h2>
		<p>
			Динамические данные могут храниться в различном формате. Некоторые форматы выглядят в RAM достаточно очевидно, например численное количество чего-либо. Некоторые могут быть непонятны на первый взгляд, вроде указателей или порядкового номера объекта.
		</p>
		<p>
			Способ хранения данных, а также то, какие именно адреса существуют, зависят от самой игры. Если ты достаточно хорошо знаком с игрой в качестве рядового игрока, а не ромхакера, тебе будет проще опознать эти адреса. С незнакомыми играми работать несколько сложнее, но в целом это не критично.
		</p>
		<p>
			Все случаи описать здесь не получится, будет рассказано только про самые распространенные. Выбери опцию из списка, чтобы посмотреть информацию по этому виду адресов.
		</p>
		<p class="tip">
			Раздел еще в разработке, ссылки будут добавлены постепенно.
		</p>
		<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Lives')">Жизни</td>
					<td class="tabLink" onclick="openTab(event, 'Timers')">Таймеры</td>
					<td class="tabLink" onclick="openTab(event, 'Counters')">Счетчики</td>
					<td>Координаты</td>
					<td>Кнопки</td>
					<td>Очки</td>
					<td>Рандом</td>
					<td>Индикаторы</td>
				</tr>
				<tr>
					<td>Параметры</td>
					<td>Музыка</td>
					<td>Графика</td>
					<td>Номера</td>
					<td>Временные</td>
					<td>Свободные</td>
					<td colspan="2">Прочие</td>
				</tr>
			</table>
		</p>
		<!--<p>
			<table border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Lives')">Жизни</td>
					<td class="tabLink" onclick="openTab(event, 'Timers')">Таймеры</td>
					<td class="tabLink" onclick="openTab(event, 'Counters')">Счетчики</td>
					<td class="tabLink" onclick="openTab(event, 'Coordinates')">Координаты</td>
					<td class="tabLink" onclick="openTab(event, 'Buttons')">Кнопки</td>
					<td class="tabLink" onclick="openTab(event, 'Points')">Очки</td>
					<td class="tabLink" onclick="openTab(event, 'Random')">Рандом</td>
					<td class="tabLink" onclick="openTab(event, 'Indicators')">Индикаторы</td>
				</tr>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Stats')">Параметры</td>
					<td class="tabLink" onclick="openTab(event, 'Music')">Музыка</td>
					<td class="tabLink" onclick="openTab(event, 'Graphics')">Графика</td>
					<td class="tabLink" onclick="openTab(event, 'ID')">Номера</td>
					<td class="tabLink" onclick="openTab(event, 'Temporary')">Временные</td>
					<td class="tabLink" onclick="openTab(event, 'Free')">Свободные</td>
					<td colspan="2" class="tabLink" onclick="openTab(event, 'Other')">Прочие</td>
				</tr>
			</table>
		</p>-->
		<p>
			<div id="Lives" class="tabcontent">
				<h2>Жизни</h2>
				<p>
					К этой категории адресов относятся не только жизни, но еще HP (Health Points - очки здоровья) и Continue (количество продолжений после Game Over).
				</p>
				<p>
					Это одни из самых популярных адресов, которые ищут новички, так как на них делаются первые тестовые хаки, связанные с изменением начальных значений и бесконечностью данных игровых параметров.
				</p>
				<h3>Оообенности</h3>
				<p>
					Количество жизней хранится в одном адресе. Встречаются 2 распространенных случая, в зависимости от кода игры на проверку Game Over и отображения жизней на экране.
				</p>
				<p>
					В первом случае количество жизней в адресе равно тому, что выводится на экране, то есть 3 жизни = #$03. Во втором случае количество жизней будет меньше на #$01, то есть 3 жизни = #$02.
				</p>
				<p>
					Персонаж гарантированно имеет некое количество жизней лишь тогда, когда он получает способность умирать и продолжать игру после смерти. Если играть без смертей, а также не получать дополнительные жизни разничными бонусами, количество жизней в адресе останется без изменений.
				</p>
				<p>
					Персонаж гарантированно теряет жизнь лишь тогда, когда тот полностью завершит анимацию смерти, чтобы он воскрес/уровень начался заново, так как в момент смерти количество жизней может сразу не измениться. Чаще всего значение в адресе будет уменьшено.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Mortal Kombat Trilogy - MK5 (вероятно и в других тоже) байт в адресе с HP может увеличиваться при получении урона, а не уменьшаться. Персонаж умрет, когда это количество достигнет определенного значения.
				</p>
				<p>
					В игре Darkwing Duck жизни хранятся сразу в двух адресах, а количество HP сразу в четырех, причем байты в этих адресах являются номерами тайлов. Это сделано для удобства отображения их количества на экране и во время паузы.
				</p>
				<h3>Методы поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Сравниваешь 2 сохранения, в которых количество жизней отличается на #$01. Также можно попробовать воспользоваться поиском предполагаемого байта и проверить все найденные адреса.
				</p>
				<p>
					В предполагаемом найденном адресе увеличиваешь количество и пробуешь умирать, проверяешь чтобы отображаемых жизней стало больше. Если количество жизней выводится на экране, возможно ты сразу увидишь изменения числа.
				</p>
				<p>
					Заморозив байт в адресе с жизнями, твой персонаж должен перестать терять жизни после смерти.
				</p>
				<p class="tip">
					Для безопасности лучше замораживать байт #$02 и выше, иначе в некоторых случаях все равно может случиться Game Over. Это зависит от особенности кода игры, который проверяет на Game Over после уменьшения жизней.
				</p>
				<h4>RAM Search</h4>
				<p>
					Отсеиваешь адреса, в которых записан байт #$00, через Not Equal To + Specific Value 00.
				</p>
				<p>
					Немного поиграв и не умерев, отсеиваешь адреса без изменений через Equal To + Previous Value.
				</p>
				<p>
					Затем умираешь, дожидаешься воскрешения и ставишь условие на Less Than/Not Equal To/Different By 01 + Previous Value для проверки на изменения.
				</p>
				<p class="tip">
					Или можно сразу поставить условие на определенное количество жизней через Equal To + Specific Value xx, но ты можешь не угадать с байтом, испортив себе весь подготовительный поиск.
				</p>
			</div>
		</p>
		<p>
			<div id="Timers" class="tabcontent">
				<h2>Таймеры</h2>
				<p>
					Под таймером подразумевается отсчет чего-либо до завершения действия этого события. К этой категории относятся таймер неуязвимости, действия бонусов, внутриигровое время и так далее. То есть длительность того, таймер чего изменяется каждый кадр (или каждый внутриигровой кадр).
				</p>
				<h3>Оообенности</h3>
				<p>
					Поскольку таймер это отсчет до завершения, скорее всего байт в адресе будет ежекадрово уменьшаться на #$01. В редких случаях будет увеличиваться на #$01.
				</p>
				<p>
					Если таймер в данный момент не используется, например когда у персонажа отсутствует неуязвимость, в адресе должно быть записано #$00.
				</p>
				<h4>Большие таймеры</h4>
				<p>
					Один адрес может хранить значение от 0 до 255. Если таймер длится дольше 255 кадров, он будет использовать сразу 2 адреса, которые в сумме создают 16-битное число, увеличивая лимит до 65535.
				</p>
				<p>
					Старший байт такого счетчика будет уменьшаться только тогда, когда полностью уменьшится младший байт счетчика. Вот пример счетчика, который считает от 600 до 0, значение уменьшается ежекадрово на протяжении 10-ти кадров.
				</p>
				<p>
					<img src="https://i.imgur.com/qvhHblH.gif"><!--0046-->
				</p>
				<p class="tip">
					Эти 2 адреса могут находиться где угодно, не обязательно по соседству друг с другом.
				</p>
				<h4>Таймер времени</h4>
				<p>
					Чтобы сэмулировать точные реальные часы, требуются адреса с терциями (терция = 1/60 секунды), секундами, минутами и, возможно, часами.
				</p>
				<p>
					Терции, секунды и минуты должны хранить байт не более #$3C (60). В зависимости от кода, это может быть байт #$3D. Минуты уменьшаются/увеличиваются после секунд, а секунды после терций.
				</p>
				<p>
					<img src="https://i.imgur.com/wlFlbAB.gif"><!--0048-->
				</p>
				<h4>Счетчик кадров</h4>
				<p>
					Этот тип адреса больше подходит к таймерам, чем счетчикам, так как его значение постоянно ежекадрово увеличивается на #$01, и его можно спутать с таймером.
				</p>
				<p>
					Счетчик кадров существует практически во всех играх. Обычно он служит для вычисления рандома. А факт того, что он увеличивается ежекадрово, позволяет легко прикручивать свои собственные ежекадровые подпрограммы к тому месту в коде, где выполняется инструкция его увеличения.
				</p>
				<h4>Особые случаи</h4>
				<p>
					В игре Battle City счетчик кадров участвует в паре с адресами таймеров бонусов для вычисления их длительности. Бонусы длятся по 10/20 секунд в небольшой погрешностью, так как при взятии бонуса счетчик кадров не изменяется.
				</p>
				<p>
					В игре Super Mario Bros. единицы, десятки и сотни у числа таймера хранятся в трех отдельных соседних адресах в формате BCD (binary-coded decimal). Подробнее про этот формат прочитаешь в подразделе с адресами очков.
				</p>
				<h3>Метод поиска</h3>
				<h4>Hex Editor</h4>
				<p>
					Побдираешь бонус/получаешь урон, затем просматриваешь адреса RAM в поисках чего-либо, что хоть как-то напоминает счетчик. Ориентируйся по самой игре, чтобы таймер в адресе и действие бонуса/неуязвимости в игре заканчивались одновременно.
				</p>
				<p>
					Адрес найден правильно, если при заморозке байта таймер неуязвимости/бонуса станет длиться бесконечно. Счетчик времени полностью остановится лишь в случае заморозки адреса с терциями.
				</p>
				<p>
					Если записать какой-то байт в таймер действия бонуса/неуязвимости, это может активировать данную игровую функцию. В противном случае вероятно существует еще какой-то адрес, в котором хранится текущее "состояние" игрока, например факт активированной неуязвимости.
				</p>
				<h4>RAM Search</h4>
				<p>
					Пока таймер деактивирован, отсеиваешь адреса, в которых записаны байты кроме #$00, через Equal To + Specific Value 00.
				</p>
				<p>
					Подобрав бонус/получив урон, отсеиваешь адреса, в которых записан байт #$00, через Not Equal To + Specific Value 00.
				</p>
			</div>
		</p>
		<p>
			<div id="Counters" class="tabcontent">
				<h2>Счетчики</h2>
				<p>
					Под счетчиком подразумевается подсчитывание количества чего-либо. Например, количество собранных бонусов, количество оставшихся врагов на уровне.
				</p>
				<p>
					В отличие от таймеров, счетчики изменяются не ежекадрово, а лишь при особом игровом событии, возникновение которого нужно подсчитать.
				</p>
				<h3>Оообенности</h3>
				<p>
					В зависимости от предназначения счетчика, он может либо увеличиваться на #$01, если нужно посчитать сколько раз было что-то сделано, или уменьшаться, например нужно убить столько-то врагов для завершения уровня.
				</p>
				<p class="tip">
					Счетчики, которые по логике должны уменьшаться, в действительности вполне могут и увеличиваться, а затем проверяться на определенное число.
				</p>
				<h4>Отдельные случаи</h4>
				<p>
					В игре Bugs Bunny Crazy Castle сбор всех морковок для завершения уровня проверяется не по счетчику морковок, а факту подбора каждой отдельной морковки, для каждой из которых выделен отдельный адрес.
				</p>
				<p>
					В игре Battle City для количества врагов выделено сразу 2 адреса. Один из них служит для подсчета количества врагов, которых нужно уничтожить на уровне. Во втором хранится количество врагов, которые еще не появились.
				</p>
				<h3>Метод поиска</h3>
				<p>
					Аналогичен поиску адресов с жизнями. А также если записать #$00 в адрес счетчика врагов, вполне возможно уровень сразу будет завершен.
				</p>
			</div>
		</p>
		<p>
			<div id="Coordinates" class="tabcontent">
				<h2>Координаты</h2>
			</div>
		</p>
		<p>
			<div id="Buttons" class="tabcontent">
				<h2>Кнопки</h2>
			</div>
		</p>
		<p>
			<div id="Points" class="tabcontent">
				<h2>Очки</h2>
			</div>
		</p>
		<p>
			<div id="Random" class="tabcontent">
				<h2>Рандом</h2>
			</div>
		</p>
		<p>
			<div id="Indicators" class="tabcontent">
				<h2>Индикаторы</h2>
			</div>
		</p>
		<p>
			<div id="Stats" class="tabcontent">
				<h2>Параметры</h2>
			</div>
		</p>
		<p>
			<div id="Music" class="tabcontent">
				<h2>Музыка</h2>
			</div>
		</p>
		<p>
			<div id="Graphics" class="tabcontent">
				<h2>Графика</h2>
				<p>
					К этой категории относится адреса, используемые в программах вывода графики на экран. Это касается отрисовка заднего фона и изменение палитры.
				</p>
			</div>
		</p>
		<p>
			<div id="ID" class="tabcontent">
				<h2>Номера</h2>
			</div>
		</p>
		<p>
			<div id="Temporary" class="tabcontent">
				<h2>Временные</h2>
				<p>
					Эти адреса внешне напоминают адреса с рандомом
				</p>
			</div>
		</p>
		<p>
			<div id="Free" class="tabcontent">
				<h2>Свободные</h2>
			</div>
		</p>
		<p>
			<div id="Other" class="tabcontent">
				<h2>Прочие</h2>
			</div>
		</p>
		<script src="https://iromhacker.ru/spoiler.js"></script>
		<script src="https://iromhacker.ru/tab.js"></script>
	</body>
</html>