<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Ромхакинг NES. Режимы адресации процессора 6502</title>
		<meta name="description" content="Подробное описание режимов адресаций процессора с примерами. A detailed description of CPU addressing modes with examples">
		<meta name="keywords" content="">
		<link rel="icon" href="https://iromhacker.ru/favicon.png" type="image/png">
		<link href="https://iromhacker.ru/style.css" rel="stylesheet">
		<script src="https://iromhacker.ru/analytics.js"></script>
	</head>
	<body>
		<h1>Режимы адресации</h1>
		<p>
			<center>
				<a class="return" href="https://iromhacker.ru/nes/ru/index.html">Вернуться на главную страницу</a>
			</center>
		</p>
		<p class="content">
			Содержание
		</p>
		<ul>
			<li><a href="../1/index.html">Центральный процессор</a></li>
			<ul>
				<li><a href="../1-1/index.html">Регистр статуса процессора</a></li>
				<li>Режимы адресации</li>
			</ul>
			<li><a href="../2/index.html">Справочник по инструкциям процессора</a></li>
			<ul>
				<li><a href="../2-1/index.html">Шпаргалка по инструкциям</a></li>
			</ul>
		</ul>
		<h2>Режимы адресации</h2>
		<p>
			Режим адресации (адресация памяти) - способ обращения процессора к своей памяти.
		</p>
		<p>
			Любая инструкция процессора состоит как минимум из опкода инструкции. В зависимости от выбранного режима адресации, после опкода может быть дополнительно записан операнд (аргумент) этой инструкции размером 1 или 2 байта. В итоге получается инструкция размером от 1-го до 3-х байтов.
		</p>
		<p class="tip">
			Разные инструкции могут использовать один и тот же режим адресации. У одних инструкций может быть больше выбора режимов адресации, чем у других.
		</p>
		<p>
			Выбери режим адресации из списка, чтобы посмотреть его описание и примеры использования.
		</p>
		<p class="tip">
			Раздел еще в разработке, ссылки будут добавлены постепенно.
		</p>
		<p>
			<table class="tab" border=1 cellspacing=1 cellpadding=5>
				<tr>
					<td class="tabLink" onclick="openTab(event, 'Immediate')">Immediate</td>
					<td class="tabLink" onclick="openTab(event, 'Zero Page')">Zero Page</td>
					<td class="tabLink" onclick="openTab(event, 'Absolute')">Absolute</td>
					<td class="tabLink" onclick="openTab(event, 'Indexed')">Indexed</td>
					<td class="tabLink" onclick="openTab(event, 'Indirect')">Indirect</td>
					<td>Relative</td>
					<td>Прочие</td>
				</tr>
			</table>
		</p>
		<p>
		<div id="Immediate" class="tabcontent">
			<h2>Immediate</h2>
			<p>
				Непосредственная адресация. Используется для работы с константами, то есть с неизменяемыми значениями, записанными в самой программе. Например, можно задать начальное количество жизней и прочитать его одним из регистров.
			</p>
			<p>
				Операнд инструкции размером 1 байт, в нем указывается константа, с которым будет работать эта инструкция.
			</p>
			<p>
				<div class="debugger_code">
					<div class="debugger_string">00:8100: A0 0F     <text class="opcode">LDY #</text><text class="address">$0F</text>	; загрузить байт #$0F в регистр Y</div>
					<div class="debugger_string">00:8102: E0 33     <text class="opcode">CPX #</text><text class="address">$33</text>	; сравнить регистр X с байтом #$33</div>
					<div class="debugger_string">00:8104: 69 1C     <text class="opcode">ADC #</text><text class="address">$1C</text>	; сложить регистр A с байтом #$1C</div>
				</div>
			</p>
			<p>
				Чтобы инструкция <text class="opcode">LDY</text> использовала режим адресации Immediate, она записывается с помощью опкода A0. После опкода ставится операнд 0F для загрузки в регистр Y байта <text class="opcode">#</text><text class="address">$0F</text>.
			</p>
		</div>
		</p>
		<p>
			<div id="Zero Page" class="tabcontent">
				<h2>Zero Page</h2>
				<p>
					Адресация нулевой страницы. Нулевой страницей являются адреса RAM в диапазоне $0000-$00FF. Старший байт адресов этого диапазона = #$00, поэтому страница называется "нулевая".
				</p>
				<p>
					8-битная адресация Zero Page служит для экономии ресурсов процессора, поскольку затрачивает меньше тактов на выполнение инструкции по сравнению с режимом адресации Absolute.
				</p>
				<p class="tip">
					По этой причине данные, которые будут использованы кодом игры чаще, чем другие, обычно находятся именно в нулевой странице для снижения нагрузки на процессор при регулярной работе с этими данными. За счет сэкономленных тактов можно успеть выполнить больше кода за кадр.
				</p>
				<p>
					Операнд инструкции размером 1 байт, которым указывается младший байт адреса. А старший байт адреса всегда будет = #$00.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: 85 4D     <text class="opcode">STA</text> <text class="address">$4D</text>    ; записать байт из регистра A в адрес $004D</div>
						<div class="debugger_string">00:8102: C6 03     <text class="opcode">DEC</text> <text class="address">$03</text>    ; уменьшить на #$01 байт в адресе $0003</div>
						<div class="debugger_string">00:8104: 45 A1     <text class="opcode">EOR</text> <text class="address">$A1</text>    ; исключающее ИЛИ байта из регистра A и байта из адреса $00A1</div>
					</div>
				</p>
				<p>
					Чтобы инструкция <text class="opcode">STA</text> использовала режим адресации Zero Page, она записывается с помощью опкода 85. После опкода ставится операнд 4D для указания адреса <text class="address">$4D</text>, в который будет записан байт из регистра A.
				</p>
			</div>
		</p>
		<p>
			<div id="Absolute" class="tabcontent">
				<h2>Absolute</h2>
				<p>
					Абсолютная адресация. Полноценная 16-битная адресация, позволяет инструкциям работать с любым адресом памяти процессора (NES Memory) в диапазоне $0000-$FFFF.
				</p>
				<p>
					Операнд инструкции размером 2 байта, ими указывается 16-битный адрес. Из-за особенностей архитектуры процессора, в операнде старший и младший байты адреса <text class="underline">всегда</text> записываются в обратном порядке, такой формат называется <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2#%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%BE%D1%82_%D0%BC%D0%BB%D0%B0%D0%B4%D1%88%D0%B5%D0%B3%D0%BE_%D0%BA_%D1%81%D1%82%D0%B0%D1%80%D1%88%D0%B5%D0%BC%D1%83" target="_blank">little-endian</a>.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: AE 23 01  <text class="opcode">LDX</text> <text class="address">$0123</text>    ; загрузить в регистр X байт из адреса $0123</div>
						<div class="debugger_string">00:8103: 0E 45 03  <text class="opcode">ASL</text> <text class="address">$0345</text>    ; арифметический сдвиг битов влево у байта в адресе $0345</div>
						<div class="debugger_string">00:8106: ED AB 89  <text class="opcode">SBC</text> <text class="address">$89AB</text>    ; вычесть из регистра A байт из адреса $89AB</div>
					</div>
				</p>
				<p>
					Чтобы инструкция <text class="opcode">LDX</text> использовала режим адресации Absolute, она записывается с помощью опкода AE. После опкода ставится операнд 23 01 для указания адреса <text class="address">$0123</text>, из которого будет загружен байт в регистр X.
				</p>
				<h3>Сравнение с Zero Page</h3>
				<p>
					Поскольку адресация Absolute затрагивает весь возможный диапазон $0000-$FFFF, ей можно указывать и адреса из нулевой страницы. Однако так делать нежелательно, ведь выполнение таких инструкций затрачивает больше тактов, чем с адресацией Zero Page, а результат выполнения инструкции будет точно такой же.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: AD 11 00  <text class="opcode">LDA</text> <text class="address">$0011</text>    ; требует 4 такта на выполнение инструкции</div>
						<div class="debugger_string">00:8103: A5 11     <text class="opcode">LDA</text> <text class="address">$11</text>      ; требует 3 такта на выполнение инструкции</div>
					</div>
				</p>
				<p class="tip">
					Необходимость прибегнуть к режиму адресации Absolute для указания адресов нулевой страницы есть только в том случае, когда у выбранной инструкции не существует варианта с адресацией Zero Page Indexed, а есть только Absolute Indexed. Например, у инструкции LDA,Y.
				</p>
			</div>
		</p>
		<p>
			<div id="Indexed" class="tabcontent">
				<h2>Indexed</h2>
				<p>
					Индексная адресация. При вычислении адреса учитывается значение индексного регистра X или Y. К адресу, указанному в операнде инструкции, добавляется текущее значение индексного регистра во время выполнения инструкции. После сложения операнда и индексного регистра получается итоговый адрес, с которым будет работать инструкция.
				</p>
				<p class="tip">
					Инструкция, работающая с индексным регистром, не может использовать этот же регистр с режимом адресации Indexed. То есть не существует инструкций вроде LDX,X или LDY,Y.
				</p>
				<p>
					Поскольку значение индексного регистра может быть в диапазоне от #$00 до #$FF, при помощи одной-единственной инструкции можно обратиться к целому диапазону размером 256 адресов, изменяя значение индексного регистра перед выполнением этой инструкции.
				</p>
				<p class="tip">
					Этот подход очень часто применяется при создании циклов и подпрограмм. А также адресация Indexed - одна из наиболее важных причин, почему однотипные адреса у различных игровых объектов, например их координаты, очень часто находятся в RAM по соседству. Ведь достаточно загрузить порядковый номер объекта в нужный индексный регистр, и можно работать с адресом именно этого объекта через ту же самую инструкуцию.
				</p>
				<p>
					Адресация Indexed может быть использована как с режимом адресации Zero Page, так и Absolute. У некоторых инструкций есть ограничение по выбору этих разновидностей адресации Indexed, в основном ограничения по использованию регистра Y.
				</p>
				<p class="tip">
					Также адресация Indexed может использоваться с адресацией Indirect, которая описана отдельно.
				</p>
				<h3>Zero Page Indexed</h3>
				<p>
					Используется вместе с адресацией Zero Page (диапазон $0000-$00FF). Поскольку указывается адрес нулевой страницы, операнд инструкции должен быть размером 1 байт.
				</p>
				<div class="debugger_code">
					<div class="debugger_string">00:8100: A9 10     <text class="opcode">LDA #</text><text class="address">$10 </text>    ; загрузить байт #$10 в регистр A</div>
					<div class="debugger_string">00:8102: A2 00     <text class="opcode">LDX #</text><text class="address">$00 </text>    ; загрузить байт #$00 в регистр X</div>
					<div class="debugger_string">00:8104: 95 99     <text class="opcode">STA</text> <text class="address">$99</text><text class="opcode">,X</text>    ; записать байт из регистра A в адрес $0099 ($0099 + #$00)</div>
					<div class="debugger_string">00:8106: E8        <text class="opcode">INX</text>          ; увеличить байт в регистре X на #$01 (X = #$01)</div>
					<div class="debugger_string">00:8107: 95 99     <text class="opcode">STA</text> <text class="address">$99</text><text class="opcode">,X</text>    ; записать байт из регистра A в адрес $009A ($0099 + #$01)</div>
					<div class="debugger_string">00:8109: E8        <text class="opcode">INX</text>          ; увеличить байт в регистре X на #$01 (X = #$02)</div>
					<div class="debugger_string">00:810A: 95 99     <text class="opcode">STA</text> <text class="address">$99</text><text class="opcode">,X </text>   ; записать байт из регистра A в адрес $009B ($0099 + #$02)</div>
				</div>
				<p>
					Чтобы инструкция <text class="opcode">STA</text> использовала режим адресации Zero Page,X, она записывается с помощью опкода 95. После опкода ставится операнд 99 для указания адреса <text class="address">$99</text><text class="opcode">,X</text>, в который будет записан байт из регистра A. Изменяя байт в регистре X, при выполнении инструкций <text class="opcode">STA</text> <text class="address">$99</text><text class="opcode">,X </text> меняется итоговый адрес, в который произойдет запись байта из регистра A.
				</p>
				<p class="tip">
					Нельзя выйти за пределы нулевой страницы, используя адресацию Zero Page Indexed. Например, выполняя инструкцию STA $FF,X с текущим значением X = #$01, байт из регистра A будет записан в адрес $0000, а не $0100.
				</p>
				<h3>Absolute Indexed</h3>
				<p>
					Используется вместе с адресацией Absolute (диапазон $0000-$FFFF). Операнд будет размером 2 байта, старший и младший байты адреса записываются в обратном порядке.
				</p>
				<p>
					В примере показан цикл, с помощью которого происходит поочередное копирование байтов из адресов $E000-$E005 в адреса $0120-$0125.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: A0 00     <text class="opcode">LDY #</text><text class="address">$00</text>       ; загрузить байт #$00 в регистр Y</div>
						<div class="debugger_string">00:8102: B9 00 E0  <text class="opcode">LDA</text> <text class="address">$E000</text><text class="opcode">,Y </text>   ; загрузить байт из адреса $E000,Y в регистр A</div>
						<div class="debugger_string">00:8105: 99 20 01  <text class="opcode">STA</text> <text class="address">$0120</text><text class="opcode">,Y </text>   ; записать байт из регистра A в адрес $0120,Y</div>
						<div class="debugger_string">00:8108: C8        <text class="opcode">INY</text>            ; увеличить байт в регистре Y на #$01</div>
						<div class="debugger_string">00:8109: C0 06     <text class="opcode">CPY #</text><text class="address">$06 </text>      ; сравнить Y с байтом #$06 (обновление состояния флага Z)</div>
						<div class="debugger_string">00:810B: D0 F5     <text class="opcode">BNE</text> <text class="address">$8102  </text>    ; перейти на адрес $8102, если Z = 0 (продолжить цикл копирования)</div>
					</div>
				</p>
				<p>
					Чтобы инструкция <text class="opcode">LDA</text> использовала режим адресации Absolute,Y, она записывается с помощью опкода B9. После опкода ставится операнд 00 E0 для указания адреса <text class="address">$E000</text><text class="opcode">,Y</text>, из которого будет загружен байт в регистр A. Изменяя байт в регистре Y, изменятся итоговые адреса в инструкциях <text class="opcode">LDA</text> <text class="address">$E000</text><text class="opcode">,Y </text> и <text class="opcode">STA</text> <text class="address">$0120</text><text class="opcode">,Y </text> при их выполнении.
				</p>
				<p class="tip">
					Нельзя выйти за пределы диапазона $0000-$FFFF, используя адресацию Absolute Indexed. Например, выполняя инструкцию LDA $FFFF,Y с текущим значением Y = #$01, байт в регистр A будет загружен из адреса $0000, а не $10000.
				</p>
				<h4>Увеличение затрачиваемых тактов</h4>
				<p>
					У некоторых инструкций при использовании адресации Absolute Indexed будет затрачен +1 дополнительный такт. Это происходит в случае перехода на новую страницу адресов, то есть когда при сложении операнда и значения индексного регистра увеличивается старший байт адреса, указанного в операнде инструкции.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: A2 0F     <text class="opcode">LDX #</text><text class="address">$0F</text>       ; загрузить байт #$0F в регистр X</div>
						<div class="debugger_string">00:8102: BC F0 06  <text class="opcode">LDY</text> <text class="address">$06F0</text><text class="opcode">,X</text>    ; $06F0 + #$0F = $06FF, 4 такта на выполнение инструкции</div>
						<div class="debugger_string">00:8105: E8        <text class="opcode">INX</text>            ; увеличить байт в регистре X на #$01</div>
						<div class="debugger_string">00:8106: BC F0 06  <text class="opcode">LDY</text> <text class="address">$06F0</text><text class="opcode">,X </text>   ; $06F0 + #$10 = $0700, 5 тактов на выполнение инструкции</div>
						<div class="debugger_string">00:8109: E8        <text class="opcode">INX</text>            ; увеличить байт в регистре X на #$01</div>
						<div class="debugger_string">00:810A: BC F0 06  <text class="opcode">LDY</text> <text class="address">$06F0</text><text class="opcode">,X </text>   ; $06F0 + #$11 = $0701, 5 тактов на выполнение инструкции</div>
					</div>
				</p>
			</div>
		</p>
		<p>
			<div id="Indirect" class="tabcontent">
				<h2>Indirect</h2>
				<p>
					Косвенная (непрямая) адресация. Итоговый адрес вычисляется исходя из байтов, находящихся в двух соседних адресах. В первом адресе находится младший байт итогового адреса, а во втором - старший байт.
				</p>
				<p>
					Эти 2 соседних адреса могут находиться в любом месте диапазона $0000-$FFFF, но в подавляющем большинстве случаев это будут адреса RAM $0000-$07FF, так как в RAM можно без труда менять байты на нужные, чтобы контролировать косвенный адрес.
				</p>
				<h3>Indirect Jump</h3>
				<p>
					Единственная инструкция, использующая режим адресации Indirect - <text class="opcode">JMP</text>. Благодаря ей можно совершать прыжки на различные участки кода, подготавливая соответствующие байты для адреса прыжка.
				</p>
				<p>
					Операнд инструкции размером 2 байта, ими указывается 16-битный адрес первого соседнего адреса. Старший и младший байты этого адреса записываются в обратном порядке.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: 6C 20 01  <text class="opcode">JMP (</text><text class="address">$0120</text><text class="opcode">)</text>    ; непрямой прыжок</div>
					</div>
				</p>
				<p>
					Адрес $0120 содержит младший байт итогового адреса, а соседний адрес $0121 - старший байт. Чтобы инструкция <text class="opcode">JMP (</text><text class="address">$0120</text><text class="opcode">)</text> совершила прыжок на адрес $89AB, нужно записать байт #$AB в адрес $0120 и байт #$89 в адрес $0121. Порядок записи не имеет значения, но первым принято записывать младший байт.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: A9 AB     <text class="opcode">LDA #</text><text class="address">$AB</text>               ; загрузка младшего байта</div>
						<div class="debugger_string">00:8102: 8D 20 01  <text class="opcode">STA</text> <text class="address">$0120</text> = #$AB       ; запись младшего байта</div>
						<div class="debugger_string">00:8105: A9 89     <text class="opcode">LDA #</text><text class="address">$89</text>               ; загрузка старшего байта</div>
						<div class="debugger_string">00:8107: 8D 21 01  <text class="opcode">STA</text> <text class="address">$0121</text> = #$89       ; запись старшего байта</div>
						<div class="debugger_string">00:810A: 6C 20 01  <text class="opcode">JMP (</text><text class="address">$0120</text><text class="opcode">)</text> = $89AB    ; итоговый адрес $89AB</div>
					</div>
				</p>
				<p>
					Если подготовить таблицу с младшими и старшими байтами, и записывать их в 2 соседних адреса RAM, выбранных в операнде инструкции Indirect <text class="opcode">JMP</text>, можно создавать любое количество развилок в своем коде.
				</p>
				<h4>Технические особенности</h4>
				<p>
					В процессоре 6502 существует баг, из-за которого нельзя выйти за пределы страницы памяти, если в операнде инструкции указать младший байт адреса #$FF.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: 6C FF 02  <text class="opcode">JMP (</text><text class="address">$02FF</text><text class="opcode">)</text>    ; младший байт считывается из $02FF, а старший байт из $0200</div>
					</div>
				</p>
				<p>
					Однако эмулятор FCEUX не эмулирует данную особенность, в нем соседним адресом будет считаться адрес $0300.
				</p>
				<h3>Post-Indexed Indirect</h3>
				<p>
					Косвенно-индексная адресация. В отличие от обычной индексной адресации, итоговый адрес контролируется при помощи регистра Y. Этот режим адресации используется для более гибкого обращения к памяти, чем обычная индексная адресация, а также при работе с таблицами, которые по размеру больше, чем 256 байтов.
				</p>
				<p>
					Для инструкции, использующей косвенно-индексную адресацию, требуется 2 соседних адреса в нулевой странице. Операнд инструкции размером 1 байт, которым указывается младший байт первого адреса нулевой страницы.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: B1 DE     <text class="opcode">LDA (</text><text class="address">$DE</text><text class="opcode">),Y</text>    ; соседние адреса $00DE и $00DF</div>
					</div>
				</p>
				<p>
					Как и в случае с обычной индексной адресацией, по соседним адресам записываются младший и старший байт итогового адреса.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: A9 80     <text class="opcode">LDA #</text><text class="address">$80</text>          ; загрузка младшего байта</div>
						<div class="debugger_string">00:8102: 85 DE     <text class="opcode">STA</text> <text class="address">$DE</text> = #$80    ; запись младшего байта</div>
						<div class="debugger_string">00:8104: A9 F0     <text class="opcode">LDA #</text><text class="address">$F0</text>          ; загрузка старшего байта</div>
						<div class="debugger_string">00:8106: 85 DF     <text class="opcode">STA</text> <text class="address">$DF</text> = #$F0    ; запись старшего байта</div>
					</div>
				</p>
				<p>
					Получив итоговый адрес $F080, можно добавлять к нему значение регистра Y, который нужно подготовить перед выполнением инструкции <text class="opcode">LDA (</text><text class="address">$DE</text><text class="opcode">),Y</text>.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8108: A0 00     <text class="opcode">LDY #</text><text class="address">$00</text></div>
						<div class="debugger_string">00:810A: B1 DE     <text class="opcode">LDA (</text><text class="address">$DE</text><text class="opcode">),Y</text> @ $F080    ; $F080 + #$00</div>
						<div class="debugger_string">00:810C: C8        <text class="opcode">INY</text>                    ; Y = #$01</div>
						<div class="debugger_string">00:810D: B1 DE     <text class="opcode">LDA (</text><text class="address">$DE</text><text class="opcode">),Y</text> @ $F081    ; $F080 + #$01</div>
						<div class="debugger_string">00:810F: C8        <text class="opcode">INY</text>                    ; Y = #$02</div>
						<div class="debugger_string">00:8110: B1 DE     <text class="opcode">LDA (</text><text class="address">$DE</text><text class="opcode">),Y</text> @ $F082    ; $F080 + #$02</div>
					</div>
				</p>
				<p>
					Это позволит работать с диапазоном памяти размером 256 адресов. Но в отличие от обычной индексной адресации, ты можешь изменять начальный адрес этого диапазона когда это небходимо.
				</p>
				<p class="tip">
					Если в операнде инструкции указать младший байт адреса #$FF, то соседним адресом будет считаться $0000, а не $0100.
				</p>
				<h3>Pre-Indexed Indirect</h3>
				<p>
					Индексно-косвенная адресация. Встречается в коде довольно редко, так как использование этого режима адресации слишком затратно и неэффективно.
				</p>
				<p>
					Отличается от косвенно-индексной тем, что здесь используется индексный регистр X. Этот регистр влияет не на итоговый адрес, а на тот адрес, откуда будут считываться младший и старший байты для итогового адреса.
				</p>
				<p>
					В примере подготавливаются младшие и старшие байты сразу в двух парах соседних адресов нулевой страницы.
				</p>
				<p>
					<div class="debugger_code">
						<div class="debugger_string">00:8100: A9 CD     <text class="opcode">LDA #</text><text class="address">$CD</text>               ; загрузка младшего байта</div>
						<div class="debugger_string">00:8102: 85 DE     <text class="opcode">STA</text> <text class="address">$DE</text> = #$AB         ; запись младшего байта</div>
						<div class="debugger_string">00:8104: A9 AB     <text class="opcode">LDA #</text><text class="address">$AB</text>               ; загрузка старшего байта</div>
						<div class="debugger_string">00:8106: 85 DF     <text class="opcode">STA</text> <text class="address">$DF</text> = #$CD         ; запись старшего байта</div>
						<div class="debugger_string">00:8108: A9 25     <text class="opcode">LDA #</text><text class="address">$25</text>               ; загрузка младшего байта</div>
						<div class="debugger_string">00:810A: 85 E0     <text class="opcode">STA</text> <text class="address">$E0</text> = #$25         ; запись младшего байта</div>
						<div class="debugger_string">00:810C: A9 05     <text class="opcode">LDA #</text><text class="address">$05</text>               ; загрузка старшего байта</div>
						<div class="debugger_string">00:810E: 85 E1     <text class="opcode">STA</text> <text class="address">$E1</text> = #$05         ; запись старшего байта</div>
						<div class="debugger_string">00:8110: A2 00     <text class="opcode">LDX #</text><text class="address">$00</text>               ; вычисление адреса из байтов в $00DE и $00DF ($00DE + #$00)</div>
						<div class="debugger_string">00:8112: A1 DE     <text class="opcode">LDA (</text><text class="address">$DE</text><text class="opcode">,X)</text> @ $ABCD    ; загрузка байта в A из $ABCD</div>
						<div class="debugger_string">00:8114: A2 02     <text class="opcode">LDX #</text><text class="address">$02</text>               ; вычисление адреса из байтов в $00E0 и $00E1 ($00DE + #$02)</div>
						<div class="debugger_string">00:8116: A1 DE     <text class="opcode">LDA (</text><text class="address">$DE</text><text class="opcode">,X)</text> @ $0525    ; загрузка байта в A из $0525</div>
					</div>
				</p>
				<p>
					По итогу всех этих действий удалось получить лишь 2 адреса - $ABCD и $0525. Слишком дорогое удовольствие с учетом того, что ради этого было выделено целых 4 адреса в нулевой странице. Чтобы повлиять на итоговые адреса, нужно изменять байты в соседних адресах нулевой страницы.
				</p>
				<p class="tip">
					Указав в операнде инструкции с индексно-косвенным режимом адресации младший байт адреса #$FF, либо попытавшись увеличить старший байт адреса при сложении значения регистра X, соседние адреса все равно будут находиться в пределах нулевой страницы.
				</p>
			</div>
		</p>
		<p>
			<div id="Relative" class="tabcontent">
			</div>
		</p>
		<p>
			<div id="Other" class="tabcontent">
				<h2>Прочие режимы адресации</h2>
				<h3>Accumulator</h3>
				<h3>Implied</h3>
				<script src="https://iromhacker.ru/spoiler.js"></script>
				<script src="https://iromhacker.ru/tab.js"></script>
			</div>
		</p>
	</body>
</html>
