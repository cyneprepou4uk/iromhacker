<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Hex Editor и NES Memory</title>
<link rel="icon" href="../../favicon.png" type="image/png">

<!-- https://metrika.yandex.ru -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
   ym(54055780, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/54055780" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- https://metrika.yandex.ru -->

<link href="../../css_js/page_style.css" rel="stylesheet">

<!-- https://sorgalla.com/lity/ -->
<link href="../../css_js/lity.css" rel="stylesheet">
<script src="../../css_js/jquery.js"></script>
<script src="../../css_js/lity.js"></script>

<script id="chatBroEmbedCode">/* Chatbro Widget Embed Code Start */function ChatbroLoader(chats,async){async=!1!==async;var params={embedChatsParameters:chats instanceof Array?chats:[chats],lang:navigator.language||navigator.userLanguage,needLoadCode:'undefined'==typeof Chatbro,embedParamsVersion:localStorage.embedParamsVersion,chatbroScriptVersion:localStorage.chatbroScriptVersion},xhr=new XMLHttpRequest;xhr.withCredentials=!0,xhr.onload=function(){eval(xhr.responseText)},xhr.onerror=function(){console.error('Chatbro loading error')},xhr.open('GET','//www.chatbro.com/embed.js?'+btoa(unescape(encodeURIComponent(JSON.stringify(params)))),async),xhr.send()}/* Chatbro Widget Embed Code End */ChatbroLoader({encodedChatId: '83WQ5'});</script>

</head>

<body>

<h1>Hex Editor и NES Memory</h1>
<p>
<a href="https://romhacking.github.io/nes/index_ru.html" target="blank">Вернуться на главную страницу</a>
</p>

<p>
Возможно ты уже имел дело с <a href="https://ru.wikipedia.org/wiki/Hex-%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%BE%D1%80" target="blank">Hex-редакторами</a>. Эти программы отображают содержимое любого файла как последовательность байтов, то есть в его сыром виде. В зависимости от того что это за файл, различные компьютерные программы интерпретируют эти байты в нечто иное, например в текст или картинку. Для эмулятора NES игр эти байты чаще всего являются либо кодом, либо игровыми данными (которые будут считаны этим кодом), либо графикой. В действительности абсолютно любая информация в ROM'е, будь то звук, графика, текст или еще что-то, должна быть записана в байтах, иначе никак. И чтобы научиться все это редактировать, нужно понимать как оно работает. Встроенный в эмулятор FCEUX Hex-редактор умеет отображать не только содержимое ROM'а как в обычном Hex-редакторе, но еще и память процессора в реальном времени с ежекадровым обновлением. В этой статье ты узнаешь как игра хранит игровые данные во время игрового процесса, взглянув на "внутренности" эмулируемой игры.
</p>

<a name="000"></a><p class="title">Содержание</p>

<ul>
<li><a href=#001>Окно Hex Editor</a></li>
<li><a href=#002>Возможности окна</a></li>
<li><a href=#003>Примеры адресов</a></li>
<ul>
	<li><a href=#011>Жизни</a></li>
	<li><a href=#012>Номер уровня</a></li>
	<li><a href=#013>Пауза</a></li>
	<li><a href=#014>Кнопки</a></li>
	<li><a href=#015>Бонусы</a></li>
	<li><a href=#016>Очки</a></li>
	<li><a href=#017>Счетчики врагов</a></li>
	<li><a href=#018>Таймеры</a></li>
	<li><a href=#019>Координаты танков</a></li>
	<li><a href=#020>Координаты в Super Mario Bros</a></li>
</ul>
<li><a href=#004>Карта NES Memory</a></li>
<li><a href=#005>Заключение</a></li>
</ul>

<a name="001"></a><p class="subtitle">Окно Hex Editor</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
В эмуляторе открой ROM <text class="file">Battle City (J) [!].nes</text> (скачай по прямой <a href="../../files/Battle City (J) [!].nes" target="blank">ссылке</a>), выбери режим 1 Player (режим переключается кнопкой <text class="button">Select</text>) и зайди на любой уровень.
</p>

<p>
<img src="../../images/006.png">
</p>

<p>
Окно <text class="object">Hex Editor</text> можно вызвать только после запуска ROM'а через <text class="path">Debug -> Hex Editor</text> (или горячей клавишей). Для полноценной работы с Hex Editor'ом нужно переключить раскладку клавиатуры на английскую.
</p>

<p>
<img src="../../images/007.png">
</p>

<p>
Изначально окно отображает всего 16 строк, я рекомендую увеличить его ровно до 32-х строк, то есть от $000000 до $0001F0. В дальнейшем я не буду указывать первые 2 нуля, я буду писать $0000 и $01F0.
</p>

<p>
<a class="data-lity" href="../../images/008.png" data-lity><img height="200" src="../../images/008.png"></a>
</p>

<p>
Во вкладке <text class="section">View</text> можно переключаться на 4 разных режима, но сейчас будем разбирать <text class="object">NES Memory</text>.
</p>

<p>
<img src="../../images/005.png">
</p>

<p>
Итак, что ты тут видишь? Большая таблица, по 16 байтов в каждой строке. Некоторые байты постоянно меняются на другие, по умолчанию такие подсвечиваются разными цветами чтобы было проще отследить изменения и найти что-то важное. Местоположение каждого байта называется <text class="object">адрес</text>. В статьях адреса будут помечены префиксом <text class="object">$</text>.
</p>

<div class="tip">
<p>
Если вдруг подсветка байтов отключена, она включается в <text class="path">Hex Editor -> Highlighting -> Highlight Activity</text>. 
</p>
</div>

<p>
Содержимое окна можно проматывать колесом мыши или ползунком справа, как в браузере. Максимум получится добраться до строки $FFF0 в самом низу окна. Пока что нас интересуют только адреса <text class="section">$0000-$07FF</text>. Это - <text class="object">оперативная память</text>, или <a href="https://ru.wikipedia.org/wiki/RAM" target="blank">RAM</a>. Диапазон адресов $0000-$07FF = 2 килобайта памяти (16 адресов * 128 строчек = 2048 адресов). А теперь сравни это со своими гигабайтами оперативной памяти на компьютере. В 90-х разработчики кое-как умудрялись пользоваться таким ограниченным количеством памяти и все равно создавать шедевры.
</p>

<p>
Оперативная память служит для того, чтобы игра могла запоминать нужные ей данные игрового процесса. При необходимости игра обращается к этим данным и может менять байты в этих адресах тем или иным способом. Все это делается при помощи кода игры, а значит текущие байты, которые сейчас находятся в адресах RAM, являются следствием выполненного игрой кода. Но смотреть на код и тем более редактировать его в этой статье мы не будем, она посвящена только изучению оперативной памяти. Ты удивишься, насколько много полезной информации об игре и ее коде можно получить лишь благодаря просмотру содержимого RAM и балуясь с переменными (байтами) в адресах.
</p>

<a name="002"></a><p class="subtitle">Возможности окна</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Расскажу про основные полезные возможности окна Hex Editor.
</p>

<h2>Изменение байтов вручную</h2>

<p>
Кликнув на адрес, ты можешь изменить записанный в нем байт. Чтобы можно было прописывать байты буквами, переключи раскладку клавиатуры на английскую. Ковыряясь в RAM, прощупывая адреса, меняя в них байты и наблюдая как это сказывается на игре, порой ты можешь довольно точно определить за что отвечает адрес, и как вообще в целом устроена игра. Это очень помогает на начальном этапе обучения, а также при работе с незнакомой тебе игрой. Желательно пользоваться сохранениями, потому что заранее не знаешь к чему приведет такое вмешательство в RAM.
</p>

<div class="tip">
<p>
Изменяя вручную значения (байты) в адресах RAM через Hex Editor, ты делаешь лишь временные изменения в игре, которые не сохранятся после закрытия ROM'а. Чтобы сохранить свои изменения, то есть создать хак этой игры, потребуется отредактировать код.
</p>
</div>

<p>
При ручной записи нового байта в адрес может произойти одно из следующих событий (рассматривая мгновенный результат):
</p>

<p>
<li><strong>Твой байт останется в адресе, и в игре что-то поменяется.</strong> Значит прямо сейчас код игры регулярно проверяет этот адрес и сразу вносит какие-то изменения в игровой процесс.</li>
<li><strong>Твой байт останется в адресе, однако в игре ничего не поменяется.</strong> Это может означать, что на данный момент этот адрес не нужен в игре (она с ним не работает), либо что этот адрес свободный (не используется игрой вообще). Ну или же адрес считывается кодом, но внешне на игре это никак не сказалось.</li>
<li><strong>Игра сразу же перезапишет твой байт на какой-то другой.</strong> Некоторые адреса могут менять свой байт множество раз за кадр. Однако окно Hex Editor делает "снимок" RAM лишь 1 раз за кадр когда игра идет в обычном режиме, поэтому просто глядя на окно ты не увидишь этих изменений. Если после ручной подмены такого байта в игре ничего не произошло, потребуется изучить участки кода игры с этим адресом для более тщательного расследования значения такого адреса.</li>
</p>

<h2>Заморозка байтов</h2>

<p>
Эта функция нужна для того, чтобы зафиксировать какой-то конкретный байт в адресе и запретить игре изменять его. В эмуляторах такая функция называется <text class="object">созданием чита</text>, список читов можно посмотреть в <text class="path">Tools -> Cheats</text>. Заморозка бывает полезной во многих случаях, и она также помогает определить для какой цели служит некий адрес. Изначально все адреса размороженные и выделены черным цветом, а после заморозки они перекрасятся в синий. В состоянии заморозки могут находиться одновременно не более 256-ти адресов. Если точнее, то количество читов не может быть более 256-ти.
</p>

<p>
Чтобы заморозить байт в адресе, кликни на нем правой кнопкой мыши и наведи курсор на <text class="section">Freeze / Unfreeze Address</text>. Предварительно можно выделить левой кнопкой мыши сразу несколько адресов, а затем кликнуть правой кнопкой по любому адресу RAM.
</p>

<p>
<img src="../../images/004.png">
</p>

<p>
Вот что означают всплывающие опции:
</p>

<p>
<li><strong>Toggle state</strong> - переключение между двумя состояниями адреса (заморожен/разморожен). Если байт в адресе уже был заморожен, он разморозится. Если был разморожен, то он заморозится. Опция будет недоступна для выбора, если при попытке заморозить адрес/адреса итоговое количество читов превысило бы или уже равно 256-ти. </li>
<li><strong>Freeze</strong> - разморозить адрес/адреса. Незамороженные адреса заморозятся, а с уже замороженными ничего не произойдет. Опция может быть недоступна по той же причине, что и <text class="section">Toggle state</text>. Я предпочитаю использовать <text class="section">Toggle state</text> вместо <text class="section">Freeze</text>, потому что эта опция первая в списке и ее удобнее выбирать, а базовая функция такая же - заморозить незамороженный адрес.</li>
<li><strong>Unfreeze</strong> - разморозить адрес/адреса. Замороженные адреса разморозятся, а с уже размороженными ничего не произойдет.</li>
<li><strong>Unfreeze all</strong> - аналогично <text class="section">Unfreeze</text>, но размораживает все замороженные адреса, а не только выделенные. Предварительно можно кликнуть на любом адресе RAM.</li>
</p>

<p>
В случае, если игра сразу перезаписывает твои ручные попытки изменить байт, ты все равно можешь запихнуть ей в адрес твой байт, просто это надо делать на паузе эмулятора, которая выставляется горячей клавишей <text class="button">Pause</text>. Поставь паузу, запиши свой байт, заморозь его, затем сними паузу. 
</p>

<div class="tip">
<p>
После разморозки байта получится одно из двух (рассматривая мгновенный результат):
<li><strong>Байт изменится на какой-то другой.</strong> Это означает, что во время заморозки байта игра пыталась записать что-то в этот адрес, и после разморозки ты увидишь результат последней из этих попыток.</li>
<li><strong>Байт не изменится.</strong> Значит игра не пыталась в него что-то записать. С другой стороны, может быть и такое, что игра последний раз пыталась записать тот же байт, что и был тобой заморожен, то есть ты не можешь быть уверен в том, твой ли это байт, или игровой. Паранойя не начнется, не?</li>
<br>
Заморозка хорошо подходит для тестирования изменений, которые ты планируешь внести в игру. Допустим тебе хочется сделать хак на бесконечные жизни. Ты замораживаешь какой-то байт в адресе с жизнями, например их изначальное количество, затем пытаешься умирать и проверяешь закончится ли игра. Если в итоге ты действительно получаешь бесконечные жизни, тебе останется обмануть игру, слегка подправив код, чтобы та всегда думала что жизни еще остались, или просто удалить код с уменьшением их количества.
</p>
</div>

<h2>Закладки</h2>

<p>
Чтобы добавить закладку для адреса, кликни на нем правой кнопкой мыши и выбери <text class="section">Add / Remove Bookmark</text>. Тебе предложат переименовать закладку перед добавлением, впоследствии переименовать ее через Hex Editor не получится (нужно будет удалить ее и добавить заново для переименования). Добавленный адрес будет выделеным зеленым цветом, однако у этого цвета низкий приоритет, и он будет перекрываться синим от заморозки или разноцветным при смене байта игрой. Чтобы удалить закладку, снова кликни на <text class="section">Add / Remove Bookmark</text> по тому же адресу.
</p>

<p>
<img src="../../images/009.png">
</p>

<div class="tip">
<p>
Даже если закрыть окошко с переименованием закладки через красный крестик справа вверху, закладка все равно будет добавлена.
<br>
<br>
Если выделить сразу несколько адресов и попытаться добавить на них закладки, она будет добавлена только на самый первый из выделенных адресов.
</p>
</div>

<p>
Список сохраненных закладок найдешь во вкладке <text class="section">Bookmarks</text>, тут же можно разом удалить все закладки через опцию <text class="section">Remove all bookmarks</text>. Кликнув на закладку из списка тебя автоматически перебросит на соответствующий адрес. На первые 10 закладок из списка можно быстро перемещаться горячими клавишами <text class="button">Ctrl</text> + <text class="button">цифра</text>.
</p>

<p>
<img src="../../images/010.png">
</p>

<p>
Закладки хранятся в одноименном файле <text class="file">.deb</text>, который автоматически создается (или обновляется если такой уже есть) в папке с ROM'ом после закрытия эмулятора/текущего ROM'а.
</p>

<p>
<img src="../../images/011.png">
</p>

<a name="003"></a><p class="subtitle">Примеры адресов</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Я буду рассказывать про некоторые адреса игры, а заодно как можно получать полезную информацию по ним и по игре, просто балуясь с RAM. Визуально найти указанный адрес из статьи очень просто. Допустим ты ищешь адрес $0035. В окне слева показаны начальные адреса строки, тебе нужна строка $0030. Кликая на адреса в этой строке, вверху в названии окна будет отображен выбранный адрес с префиксом <text class="object">0x</text> и без лишних нулей слева, и ты можешь быстро сориентироваться.
</p>

<p>
<img src="../../images/003.png">
</p>

<div class="tip">
<p>
Префикс <text class="object">0x</text> используется в языках программирования с C-подобным синтаксисом, например в языке C++ (на котором написан эмулятор FCEUX). Но там этим префиксом может быть указан как байт, так и адрес. В некоторых других документах по ромхакингу ты можешь встретить префикс при указании адресов. Я тоже буду его использовать, но только для указания адресов конкретно в <text class="path">View -> ROM File</text>.
</p>
</div>

<p>
Или ты можешь сразу перейти на нужный адрес. Для этого вызови окошко <text class="object">Goto</text> комбинацией <text class="button">Ctrl</text> + <text class="button">A</text> или <text class="button">Ctrl</text> + <text class="button">G</text>, запиши адрес и нажми <text class="button">Enter</text> или <text class="button">Ok</text>. Адрес можно записывать без лишних нулей слева, а еще с префиксом 0x (если вдруг тебе так захочется). Префикс $ записывать нельзя, иначе тебя в любом случае перекинет в самый конец окна.
</p>

<p>
<img src="../../images/012.png">
</p>

<div class="tip">
<p>
В какой-нибудь другой игре номера адресов, указанных в этой статье, очень навряд ли будут такими же, как в Battle City. Только разработчики решают за что будет отвечать какой-то из 2048 адресов. Схожее расположение адресов в лучшем случае ты встретишь у игр одной серии, или в играх одной и той же компании.
</p>
</div>

<a name="011"></a><h2>Жизни</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Находясь в Battle City на любом уровне, найди адрес $0051 - здесь хранится количество жизней первого игрока. Адрес считывается игрой дважды за кадр, и изменяя байт вручную ты сразу заметишь результат. Первый раз игра считывает его для отображения количества жизней на экране справа внизу. Причем игра специально отображает их на 1 меньше, чем записанный там байт. Если там записано #01, будет отображено 0 жизней, если #02, то отобразится 1 жизнь, и так далее. 
</p>

<div class="tip">
<p>
Я еще с детства заметил что разные игры по-разному отображают счетчик жизней, наверное создатели игр так и не определились со стандартом. Если взять случай, когда следующая смерть персонажа приведет к Game Over'у, некоторые игры отображают количество жизней как 1, а некоторые как 0. На это отчасти влияет то, как именно разработчик решает написать код с проверкой на Game Over. Мне 0 кажется логичнее. А ты что думаешь?
</p>
</div>

<p>
Если записать туда байт от #65 до #80, то в счетчике жизней на экране у десятков начнут отображаться какие-то буквы. А если записать байт #81 и выше, то игра будет отображать якобы 0 жизней, и судя по коду игры это было сделано специально.
</p>

<div class="tip">
<p>
С неправильным отображением десятков у чисел выше 99 ты наверняка еще не раз столкнешься в других играх. Связано это с тем, что код игры некорректно обрабатывает десятичные числа, и, например, если у нас число 100, игра будет думать, что количество десятков = 10, а не 0, как должно быть на самом деле, не говоря уже о том, что нужно отобразить количество сотен. И в этом случае, если посмотреть на графику в Battle City (<text class="path">Debug -> PPU Viewer</text>), в середине правого окна ты увидишь цифры, а сразу за ними красные буквы, которые игра и начинает брать для отображения жизней, просто потому что они следующие по списку, где после 9 якобы находится 10.
<br>
<br>
<img src="../../images/013.png">
<br>
<br>
Как по мне, разработчики тупо поленились сделать в коде нормальную проверку на количество жизней, чтобы они отображались правильно. Даже если почти нереально набрать такое большое количество жизней, теоретически это все же возможно, и код составляется достаточно просто, так что это косяк. Некоторые игры отображают 99 жизней когда их количество превышает 99, этот вариант был бы более приемлимым.
</p>
</div>

<p>
Второй раз игра считывает $0051 для проверки на Game Over. Каждый кадр игра пытается вызвать Game Over при условии, что жизни будут равны #00. Таким образом ты можешь вызвать его самостоятельно, даже пока твой танк еще жив, если запишешь туда #00. Примечательно то, что ты сможешь продолжать двигаться своим танком еще некоторое время, пока экран не сменится на подсчет очков. Это можно было бы назвать багом, но разработчики в 1985-м году не могли предположить, что сегодня ты будешь вручную менять байты в RAM. Так что тут все в порядке, на этот раз мы их прощаем.
</p>

<p>
Если ты заморозишь в адресе любой байт кроме #00 и #01, ты получишь бесконечное количество жизней, потому что игре будет постоянно насильно скармливаться твой байт. После смерти игрока игра будет тщетно пытаться уменьшить количество жизней на #01, а поскольку результат #00 невозможен из-за заморозки, следовательно и Game Over не появится (хотя игру все же можно будет закончить уничтожением базы). В то же время ты не будешь получать дополнительные жизни при взятии бонуса и наборе 20.000 очков, из-за тщетных попыток игры увеличить количество на #01.
</p>

<div class="tip">
<p>
Нельзя замораживать байт #01 в адресе с жизнями в Battle City, если ты добиваешься бесконечных жизней. Если ты уже знаком с флагами процессора, ты возможно знаешь что при вычитании #01 из байта (или через уменьшение на #01 байта в адресе напрямую), коду игры достаточно проверить результат по флагу Z без необходимости повторно считывать байт из адреса с жизнями. Поэтому заморозив байт #01 и умерев, Game Over все равно появится. Такой результат может намекнуть тебе на то, как выглядит этот код, когда ты станешь немного опытнее. Это встречается не во всех играх, все зависит от самого кода. И подобная ситуация относится не только к адресам с жизнями.
<br>
<br>
В некоторых случаях заморозка может не привести к желаемому результату. Например в игре RoboCop 2 при получении урона игра обновляет на экране количество оставшегося <text class="object">HP</text> (Health Points - очки здоровья). Однако код игры не обращается напрямую к адресам HP когда пытается вывести их на экран. Вместо этого после вычисления оставшегося HP игра дополнительно хранит результат в других адресах, используемых для вывода графики. Поэтому если заморозить адреса HP, то при получении урона уровень HP на экране все равно уменьшится, однако в действительности (в адресе HP) он останется нетронутым. Ты все равно получишь временную бессмертность от урона врагов пока байт заморожен, хоть и чутка кривоватую.
</p>
</div>

<p>
Сразу же за $0051 находится $0052 - адрес жизней второго игрока. Очень часто однотипные адреса схожих игровых объектов будут находиться по соседству. Такой метод расположения адресов удобен из-за кода, составляемого для обработки подобных адресов. В $0052 запишутся жизни, если выбрать режим 2 Players в главном меню и зайти на любой уровень.
</p>

<div class="tip">
<p>
Если ты, <text class="underline">уже</text> находясь на каком-то уровне в режиме 1 Player, вручную запишешь в $0052 какой-то байт, то второй игрок не возродится. Игра не пытается ежекадрово воскресить игрока через считывание его количества жизней. Респаун (возрождение) игроков происходит сразу после отрисовки уровня, либо после смерти этого игрока (если у него остались жизни). А раз игрока на данный момент на уровне не существует, то и умереть он не может, и изменение байта в адресе его не воскресит. Единственное чего ты добьешься - запретишь случиться Game Over когда первый игрок потеряет все свои жизни, потому что для этого #00 жизней должно быть у обоих игроков одновременно (независимо от режима). Игра продолжится, думая что второй игрок все еще живой из-за адреса с жизнями, хоть на экране его танка и не будет.
<br>
<br>
Ты все же можешь заставить второго игрока появиться на уровне в режиме 1 Player. Зайди на экран выбора уровня, и вручную запиши количество жизней в адрес $0052. При запуске уровня игра прочитает адрес, и второй игрок возродится. Однако на экране не отобразится его количество жизней, а также врагов будет появляться максимум 4, а не 6, как в режиме 2 Players, потому что эти игровые параметры зависят не от факта существования второго игрока, а непосредственно от режима игры.
</p>
</div>

<p>
Попробуй самостоятельно определить адрес, отвечающий за режим игры, находясь в главном меню, переключая режим кнопкой <text class="button">Select</text> и наблюдая за изменениями в адресах RAM. Для подтверждения догадки поменяй вручную байт в адресе и/или заморозь его, а затем зайди на уровень. Правильный ответ - <text class="hidden">$0083</text> (выдели мышкой скрытый текст слева для просмотра, но не подглядывай раньше времени).
</p>

<a name="012"></a><h2>Номер уровня</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Сделай <text class="button">Soft Reset</text> горячей клавишей и зайди на экран с выбором уровня. Пока ты находишься на этом экране, в RAM будет почти гробовая тишина, работают лишь какие-то счетчики, и любые новые изменения сразу бросятся в глаза. Глядя на начальную страницу адресов RAM и начиная постепенно увеличивать номер уровня кнопкой <text class="button">A</text>, можно заметить сразу 2 адреса, теоретически подходящих под хранение номера уровня - $003B и $0085. С 1-го по 9-й уровень байты в них будут одинаковые, однако после 10 и выше $0085 будет вести себя как шестнадцатеричное число, а к $003B подключится еще и $003A, и эти соседние адреса будут симулировать десятичное число. То есть выбрав 15-й уровень, у тебя будет $0085 = #0F, а в $003A (десятки) и $003B (единицы) будут #01 и #05 соответственно, и если игнорировать нули, получится #1 и #5. Если номер уровня ниже 10, то количество десятков в $003A = #00. $003A и $003B зависимы от $0085, ведь при попытке перезаписать в них байт вручную он сменится обратно, а меняя вручную $0085 будут также меняться и те 2 адреса. Следовательно настоящим номером уровня является $0085, а те двое служат лишь для отображения этого номера уровня на экране.
</p>

<div class="tip">
<p>
На самом деле в адресах $003A и $003B нету необходимости, номер уровня вполне можно отобразить работая лишь с одним только $0085, то есть без посредников. Но видимо игре так удобнее, в таких случаях в коде возможно существует некая общая программа отрисовки чисел на экране, и нужно лишь сказать ему откуда считать это число. В данном случае это номер уровня $0085, но это также может быть и количество жизней игрока. Обрати внимание на эти 2 адреса, вручную изменяя количество жизней 1-го игрока во время игры на уровне.
</p>
</div>

<p>
Игра не позволит тебе выбрать уровень выше 35 (#23) на этом экране, но тебя же это не остановит. В Battle City при прохождении 35-го уровня игра начинается заново по второму кругу, повысив сложность игры, а номер уровня продолжает увеличиваться. И видимо игра вносит еще какие-то изменения в RAM, потому что вручную записав уровень выше 35 и запустив его, ты увидишь глючных врагов. Игра все равно поймет что ты находишься якобы на втором круге, поэтому уровни 36-70 будут аналогичны 1-35, как и предполагалось.
</p>

<p>
Игра заканчивается на 70-м уровне и возвращается к 1-му. Если записать в $0085 байт выше, чем игра на то рассчитана, начнут грузиться какие-то левые уровни. Номер уровня сам по себе является указателем на область памяти, откуда начинают считываться данные для составления уровня. А превысив лимит ты выходишь за пределы этой таблицы данных и заставляешь игру читать байты, которые могут являться чем угодно, отсюда ты получаешь на экране всякий мусор. Но это еще не так страшно, игра и вовсе могла бы повиснуть если читает не то, что было запланировано. И опять же при записи номера уровня 100 и выше ты увидишь неправильное отображение десятков у числа, как в случае с жизнями.
</p>

<div class="tip">
<p>
Хоть игра и запрещает тебе выбрать уровень выше 35-го, но вручную записав в $0085, например, 36-й, ты сможешь проматывать и дальше, а пройдя целый круг и вновь достигнув 35-го, снова сработает то ограничение. Это происходит потому, что в коде игры прописано условие "запретить увеличение уровня при попытке записи 36-го", а не "36-го <text class="underline">и выше</text>", из-за этого ты и крутишь счетчик вперед до упора. Хотя с точки зрения качества работы Battle City код написан как надо, ведь невозможно перескочить 35-й уровень на экране выбора без изменения байта вручную через RAM. А вообще для создания проверки на "36 и выше" достаточно поменять всего 1 байт в коде.
</p>
</div>

<a name="013"></a><h2>Пауза</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
$006D - это пример адреса, играющего роль переключателя. Такие адреса обычно оперируют каким-то из битов, чаще всего нулевым (напомню, что нулевой бит - это порядковый номер крайнего бита справа), отсюда и 2 возможных байта, которые ты увидишь - либо #00, либо #01. Нажав кнопку <text class="button">Start</text>, игра меняет состояние бита на противоложный (с 0 на 1 и наоборот). Если в адресе #00, то игра продолжается, а если любой другой байт (главное что это не #00), то включается пауза. Но находясь на паузе игра все-таки ожидает не любой байт, а именно #01, чтобы поменять состояние нулевого бита и проверить на результат #00 для выхода из паузы, иначе ты не сможешь снять паузу кнопкой <text class="button">Start</text>, игра лишь будет тщетно переключать состояние нулевого бита в $006D.
</p>

<div class="tip">
<p>
При выставлении паузы вручную через RAM ты не услышишь звук паузы, потому что этот звук должен воспроизводиться только тогда, когда игра увидит что пользователь нажал кнопку <text class="button">Start</text>. А раз этого не случилось из-за ручной записи байта, то программа выставления звука паузы не выполнялась, и игра не узнает что нужно было воспроизвести этот звук.
<br>
<br>
Поскольку игра в данном случае использует только 1 бит из 8, остаются еще 7 свободных битов. При желании за счет одного такого адреса можно придумать сразу 8 переключателей. Исходя из возможностей процессора, удобнее создавать переключатели через нулевой, шестой и седьмой биты.
</p>
</div>

<a name="014"></a><h2>Кнопки</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Адреса с кнопками можно было заметить, находясь на экране с выбором уровня. Посмотри на адреса $0006-$0009. В адресе $0006 показано удержание кнопок, если их нажать и не отпускать, он нужен для передвижения танка пока пользователь удерживает направление на джойстике. В $0008 показано одноразовое нажатие кнопки, даже при удержании, нажатие хранится в течении 1 кадра. Такой адрес служит для стрельбы, выставления/снятия паузы, переключения режима в главном меню, и прочих ситуаций, где для некого действия требуется лишь единожды нажать на кнопку. Адреса $0007 и $0009 имеют такое же значение, но уже для второго джойстика. Игра считывает эти адреса и заставляет твой танк двигаться и стрелять соответственно. При ручной попытке изменения байта он будет перезаписан игрой, потому что код чтения портов джойстиков ежекадрово обновляет переменные в этих адресах в зависимости от нажатий.
</p>

<div class="tip">
<p>
Почти невозможно нажать и отпустить кнопку таким образом, чтобы нажатие было зафиксировано только на протяжении 1 кадра. Даже если быстро кликнуть на кнопку, между нажатием и отпусканием пройдет несколько кадров. Поэтому если бы игра проверяла для паузы не $0008, а $0006, было бы очень неудобно поставить и снять паузу. Заморозив байт #08 (кнопка <text class="button">Start</text>) в адресе $0008 во время игры на уровне, ты поймешь как бы это примерно выглядело.
</p>
</div>

<p>
На джойстике 8 кнопок, и каждой кнопке соответствует какой-то из 8 битов, из которых составляются байты в адресах кнопок. Можно легко выяснить какой байт за какую кнопку (или комбинацию кнопок) отвечает, и заморозить этот байт в правильном адресе во время паузы эмулятора, чтобы заставить танк двигаться в какую-то сторону или непрерывно стрелять без необходимости что-то нажимать или удерживать. Обычно биты 0-3 отвечают за кнопки направления, а биты 4-7 за остальные 4 кнопки на джойстике. В зависимости от кода бывает и наоборот, но реже, и Battle City в числе таких игр.
</p>

<div class="tip">
<p>
В более сложных играх в RAM может быть выделено несколько дополнительных адресов с кнопками, а не только по 2 главных адреса на каждый джойстик. Например, некая игра будет хранить отпущенные тобой кнопки, чтобы ты мог заряжать оружие пока держишь кнопку, и проверять какую ты отпустил чтобы выстрелить заряд. Или же в течении нескольких кадров она будет суммировать твои нажатые кнопки, чтобы дать тебе возможность успеть нажать комбинацию <text class="button">A</text> + <text class="button">B</text> для прыжка.
<br>
<br>
Очень часто в играх, где можно играть только первым игроком, также выделены адреса кнопок и для 2-го игрока, которые хоть и фиксируют нажатия со 2-го джойстика, но фактически нигде не используются.
<br>
<br> 
Если на начальном игровом экране ничего не нажимать, запускается демо-режим, в котором танками игроков управляет <text class="object">AI</text> (Artificial Intelligence - искусственный интеллект). AI игроков в Battle City довольно примитивный - гоняется за врагами и за бонусами, не видит препятствий на уровне и стреляет без остановки. Чтобы управлять танками игроков, AI просто записывает нужные байты в адреса с кнопками. А код игры, который обрабатывает эти адреса, выполняет действия игрока исходя из этих "нажатий", и он не отличает компьютер от реального игрока. Если подменить записи AI на настоящие нажатия из джойстика, можно дать второму игроку управлять компьютером в тех играх, где изначально нельзя играть вторым игроком. Но такой способ управления компьютером есть не во всех играх.
<br>
<br>
Некоторые клавиатуры не позволяют тебе нажимать одновременно несколько определенных кнопок. Это зависит от самой клавиатуры, а также от расположения контактов этих кнопок на ее плате. Если тебе вдруг понадобилось нажать комбинацию кнопок для игры, например <text class="button">A</text> + <text class="button">B</text> + <text class="button">Select</text>, а клавиатура не позволяет тебе это сделать, нужно переназначить управление на другие кнопки в настройках эмулятора, или же заморозить соответствующий байт в нужном адресе с кнопками.
</p>
</div>

<a name="015"></a><h2>Бонусы</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Выбей бонус из бонусного (красного и мигающего) танка. Такой враг появляется четвертым по списку в начале каждого уровня. Пока не поднимай выбитый бонус, подъедь к нему поближе и сделай сохранение для будущих тестов. Найди адрес $0088, он отвечает за тип бонуса. Всего в игре 7 бонусов, это байты #00-#06. При смене байта поменяется и сам бонус. Остальные байты не предусмотрены - начнет меняться графика бонуса на всякий бред, а взятие такого кривого бонуса приведет к зависанию игры, перезагрузке или другим багам.
</p>

<p>
При убийстве бонусного врага номер бонуса выбирается рандомно, от #00 до #05. А бонус <text class="object">пистолет</text> (#06) исключен из списка для рандома, он является <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%81%D1%85%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%8F%D0%B9%D1%86%D0%BE_(%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5)" target="blank">пасхалкой</a>, при его взятии кроме 500 очков ты ничего не получишь. Существуют хаки Battle City, где пистолет прокачивает твой танк на максимум. При заморозке адреса бонус будет появляться один и тот же независимо от рандома.
</p>

<div class="tip">
<p>
Графику бонусов, как и танков и прочей графики <text class="object">спрайтов</text> (графических объектов поверх фона), можно посмотреть в PPU Viewer, если поставить галочку на <text class="section">Sprites 8x16 mode</text>. Режим спрайтов с размером 8x16 есть не во всех играх, нужно снимать галочку для просмотра спрайтов размером 8x8 или графики фона (подробнее прочитаешь в разделах с графикой). Кликая правой кнопкой мыши на левой/правой части окна с графикой, можно менять наборы палитры, используемые для отображения графики в окне, которые в данный момент находятся в видеопамяти. Всего 9 наборов: 4 для фона (верхняя строчка с цветами) + 4 для спрайтов (нижняя строчка) + 1 фиксированная черно-белая, встроенная в эмулятор.
<br>
<br>
<a class="data-lity" href="../../images/002.png" data-lity><img height="200" src="../../images/002.png"></a>
</p>
</div>

<a name="016"></a><h2>Очки</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
В отличие от жизней, количество которых хранится в одном-единственном адресе для каждого игрока, количество очков расположено сразу в нескольких адресах. Хотя бы потому, что один адрес в состоянии хранить число не более 255, а количество очков может достигать нескольких миллионов. Поэтому Battle City хранит очки в нескольких адресах, и каждый адрес симулирует некий разряд десятичного числа. Такой формат хранения числа в нескольких адресах называется <text class="object">Binary-coded decimal</text> (двоично-десятичный код), или просто <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE-%D0%B4%D0%B5%D1%81%D1%8F%D1%82%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4" target="blank">BCD</a>. Он применяется для числовых значений (обычно 100 и выше), которые нужно вывести на экран. Написать такой код обработки числа сложнее, зато отобразить это число на экране становится гораздо проще и удобнее. Ты уже встречался с BCD, когда наблюдал за адресами $003A и $003B при выборе уровня и изменении количества жизней, эти 2 адреса симулируют разряды десятичного числа.
</p>

<div class="tip">
<p>
Некоторые игры, к примеру Darkwing Duck, вместо цифры могут хранить в этих адресах номер <text class="object">тайла</text> (изображение размером 8x8 пикселей, использующееся для отрисовки фона и спрайтов). Если брать в пример Battle City, где цифра 1 для отображения жизней это тайл под номером #6F, игра может хранить символ 1 в байте #6F, и точно также изменять этот байт при изменении разряда числа. Это избавляет от необходимости каждый раз добавлять к байту корректировку для правильного вывода соответствующего номера тайла цифры во время отрисовки ее на экране.
<br>
<br>
Для хранения числа больше 255 (#FF), которое не нужно выводить на экране, использовать BCD не всегда удобно. Предпочтительнее хранить это число сразу в двух адресах, имитируя 16-битное число, что увеличивает лимит уже до 65535 (#FFFF). Причем эти адреса могут находиться на любом расстоянии друг от друга в пределах RAM, а не только по соседству (и в случае с BCD тоже). Этот дополнительный второй адрес называется <text class="object">старшим</text> адресом, а обычный называется <text class="object">младшим</text>. Находящиеся в них байты также называются <text class="object">старшими</text> и <text class="object">младшими</text> байтами соответственно.
</p>
</div>

<p>
Очки первого игрока находятся по адресам $0015-$001B, а второго в $001D-$0023.
</p>

<p>
<table border=1 cellspacing=1 cellpadding=5>
<tr><td>Адрес первого игрока</td><td align="center">$0015</td><td align="center">$0016</td><td align="center">$0017</td><td align="center">$0018</td><td align="center">$0019</td><td align="center">$001A</td><td align="center">$001B</td></tr>
<tr><td>Адрес второго игрока</td><td align="center">$001D</td><td align="center">$001E</td><td align="center">$001F</td><td align="center">$0020</td><td align="center">$0021</td><td align="center">$0022</td><td align="center">$0023</td></tr>
<tr><td>Значение адреса</td><td>Миллионы</td><td>Сотни тысяч</td><td>Десятки тысяч</td><td>Тысячи</td><td>Сотни</td><td>Десятки</td><td>Единицы</td></tr>
</table>
</p>

<p>
Игра следит за тем, какой из игроков набирает очки, и записывает в соответствующие адреса. Если при сложении очков байт в адресе превысит #09, игра увеличивает байт в соседнем адресе слева, отвечающем за разряд постарше, а остаток записывает в текущий адрес. Допустим у первого игрока сейчас 800 очков, значит $0019 = #08, а в остальных адресах очков записано #00. За подбор бонуса дается 500 очков, то есть нужно добавить #05 сотен к очкам игрока. #08 + #05 = #0D. Игра проверит на превышение или равенство байту #0A (10), отрежет лишние #0A, запишет остаток #03 в $0019 и увеличит $0018 на #01. Пример можно воспроизвести самостоятельно, выбив бонус, записав нужные байты в адреса очков и подобрав этот бонус.
</p>

<div class="tip">
<p>
В Battle City количество миллионов не выводится на главном экране и при подсчете очков после завершения уровня, однако учитывается в рекорде (Hi-Score) и появляется на экране с рекордом после Game Over. В игре нету проверки на 9.999.900 очков, поэтому превысив это количество отсчет пойдет с 0 очков.
<br>
<br>
Количество десятков и единиц отображается на экранах, это можно проверить если вручную туда что-то записать, но в игре нельзя набрать меньше 100 очков за раз, поэтому эти адреса по сути не задействованы. Обычно игры самостоятельно приписывают лишние 2 нуля в счетчике на экране, а адресов с десятками и единицами на самом деле не существует.
<br>
<br>
В известном хаке Battle City под названием <text class="object">Tank 1990</text>, если враг поднимет бонус <text class="object">пистолет</text>, за убийство такого врага дают 10 очков.
</p>
</div>

<a name="017"></a><h2>Счетчики врагов</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
В игре есть сразу 2 счетчика врагов, у каждого своя задача и оба адреса по своему важны. На каджом уровне по 20 врагов. Если бы в Battle City все враги на уровне появлялись одновременно, хватило бы и одного адреса, но здесь они появляются постепенно, а также максимальное количество врагов на экране зависит от режима игры.
</p>

<p>
Первый адрес - $007F. Он отвечает за количество врагов, которые еще не появились. Это количество отображено справа на экране в виде значков танков.
</p>

<p>
<img src="../../images/015.png">
</p>

<p>
Как только новый враг начинает возрождаться в одной из трех точек респауна, байт в адресе уменьшится на #01, и игра сотрет один значок (меняет тайл значка танка на тайл серого квадрата). Когда счетчик достигнет #00, новые враги появляться не будут после убийства тех, которые сейчас на экране. Если досрочно обнулить адрес (записать #00), новые враги перестанут возрождаться, но уровень не закончится и звук передвижения врагов не затихнет. То есть адрес $007F контролирует возрождение врагов.
</p>

<p>
Этот адрес отвечает еще и за появление бонусного танка. Враги, возрожденные под порядковыми номерами 4, 11 и 18, окажутся бонусными. Например если заморозить в этом адресе байт #11, ты заставишь игру думать что любой новый враг возрождается 4-м по счету, и все они будут превращаться в носителей бонуса. При появлении бонусного танка игра удаляет текущий бонус с экрана, поэтому поднять хоть какой-нибудь бонус станет довольно непросто.
</p>

<div class="tip">
<p>
Технически игра не удаляет бонус из RAM при появлении нового бонусного танка, она просто перемещает его в левую часть экрана, где он не отображается и где его невозможно подобрать. Ты можешь "вытащить" его оттуда, изменив координату бонуса по горизонтали в адресе $0086.
</p>
</div>

<p>
Игра единожды отрисовывает все значки при загрузке уровня, и будет по очереди затирать их при респауне врагов. У игры нету необходимости проверять состояние этих значков, она только вычисляет координаты тайла фона исходя из байта в этом адресе, а затем подменяет тайл в нужном месте. Поэтому если вручную уменьшить байт в $007F, игра начнет затирать значки относительно величины этого байта, который ты записал, а оставшиеся значки затерты не будут. Если ты убьешь несколько врагов а потом запишешь байт чуть побольше, игра будет пытаться затирать уже затертые значки. 
</p>

<p>
<img src="../../images/016.png">
</p>

<p>
Второй счетчик - $0080. В нем хранится общее количество оставшихся на уровне врагов, неважно есть они на экране или еще нет. Если точнее, это то количество врагов, которое нужно уничтожить для прохождения уровня. Когда враг завершает анимацию взрыва после его убийства (то есть когда игра действительно посчитает объект мертвым), счетчик уменьшится на #01. При достижении счетчиком #00 игра решит что уровень пройден, запустится таймер завершения уровня и вскоре наступит подсчет очков. Если досрочно обнулить $0080, уровень завершится после отсчета таймера даже с оставшимися врагами на экране, причем звук их передвижения не будет воспроизводиться. Значит для воспроизведения звука игра смотрит на адрес $0080, а не проверяет адреса каждого отдельного врага в поисках живых.
</p>

<p>
Попробуй самостоятельно найти счетчики убитых врагов различного типа для обоих игроков, которые понадобятся игре после завершения уровня на экране подсчета очков. Правильный ответ - <text class="hidden">$0073-$0076 у первого игрока, $0077-$007A у второго игрока.</text>
</p>

<a name="018"></a><h2>Таймеры</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Если игре нужно знать когда закончится или сколько будет длиться некое действие, начинай искать таймер. Таймеры в большинстве случаев найти достаточно просто - обычно байт в адресе будет постоянно уменьшаться на #01. Реже байт будет увеличиваться. В зависимости от длительности таймера, адресов может быть несколько, и они будут частью общего таймера. Если таймеру не достаточно 255 кадров (4,25 секунд), то есть когда отсчет идет увеличением с #00 до #FF или уменьшением с #FF до #00, ищи дополнительные адреса, которые совместно будут хранить число больше, чем 255.
</p>

<div class="tip">
<p>
Если игра пытается имитировать реальные часы, то будет существовать некий адрес, хранящий <text class="object">терции</text> (1/60 секунды), то есть максимальный байт в нем скорее всего #3C (60) или #3D (61, это бывает реже, зависит от кода), а также отдельные адреса для количества секунд и минут, и все это будет частью одного таймера.
</p>
</div>

<p>
В качестве одиночного таймера могу привести пример $004F, когда в начале игры главное меню начинает скроллиться вверх (скроллинг - движение фона по горизонтали/вертикали). Таймер увеличивается ежекадрово и меню плавно двигается снизу вверх. Отсчет начинается с #00 и заканчивается на #EF. Если заморозить адрес, меню зависнет на месте до разморозки.
</p>

<div class="tip">
<p>
Этот адрес является не просто таймером движения меню, а еще и координатой камеры, относительно которой отображается фон. Чтобы в этом убедиться, дождись пока меню доскроллится примерно до #B0, затем поставь эмулятор на паузу, заморозь байт например #50, сними паузу с эмулятора, и ты увидишь как меню резко опустится вниз. Разморозь адрес и меню снова начнет подниматься.
</p>
</div>

<p>
Теперь пример посложнее с двумя адресами сразу. Выбей бонус <text class="object">лопата</text> ($0088 = #02) и подбери его. Таймер действия бонуса находится в $0045, это основной адрес. Эффект бонуса длится чуть дольше 20 секунд, поэтому очевидно что одного адреса недостаточно. Игре нужно знать когда уменьшать байт в адресе, для этого используется дополнительный адрес $000B. Когда байт в этом адресе равен #3F, #7F, #BF или #FF, только тогда уменьшается $0045. В итоге получается уменьшение основного таймера каждую секунду, а если точнее то каждые 64 кадра, потому что интервал между теми 4-мя байтами равен #40.
</p>

<div class="tip">
<p>
На самом деле игра не проверяет на каждый из этих байтов по отдельности, она ждет когда в байте первые 6 битов одновременно будут равны 1, отсюда и вытекают те 4 байта. Для проверки битов существуют специальные удобные команды процессора, из которых написан такой код.
</p>
</div>

<p>
Как только в $0045 будет #03 или меньше, защита базы начнет моргать, сообщая игроку что действие бонуса заканчивается. Для интервала моргания опять же используется $000B с интервалом в #10 (16 кадров), начиная с #00. У моргания есть 2 состояния - кирпичи и бетон. Чтобы отличать эти 2 состояния, проверяется 4-й бит, в зависимости от которого рисуется та или иная защита базы. Само моргание не влияет на скорость уменьшения $0045, это отдельная программа.
</p>

<p>
Итого мы получаем очень примитивный и практически точный секундный таймер длительностью чуть больше 20 секунд, а под конец база моргает почти 4 раза в секунду. А поскольку $000B постоянно увеличивается во время игры, существует дополнительная погрешность таймера в зависимости от того, какой байт находился в адресе при взятии бонуса.
</p>

<div class="tip">
<p>
Замораживая любой байт в $000B, на экране пропадет вся графика спрайтов, игра зависнет, будет работать лишь звуковой движок. Отвиснет только после разморозки. Углубляться в это я сейчас не стану, скажу лишь что код игры очень сильно рассчитывает на то, что на новом кадре байт в этом адресе будет отличаться от байта на предыдущем кадре. А замораживая байт игра получит точно такой же байт на следующем кадре, что и был на предыдущем.
<br>
<br>
Не обязательно подбирать <text class="object">лопату</text> чтобы защитить базу, можно просто записать в $0045 какой-то байт. Игра регулярно проверяет этот таймер на наличие оставшегося времени, поэтому защита базы активируется как после поднятия бонуса. Такой же прием очень часто можно применить в играх, где персонаж получает кадры неуязвимости (Iframes - invulnerability frames) при получении урона, обычно тоже достаточно просто что-то вручную записать в адрес таймера. Если же запись не сработала, возможно где-то в RAM существует некий индикатор неуязвимости, и для активации неуязвимости его тоже нужно подправить вручную.
</p>
</div>

<p>
Попробуй самостоятельно найти основной адрес с таймером бонуса <text class="object">каска</text> для обоих игроков, дающая им неуязвимость, и бонуса <text class="object">часы</text>, который замораживает врагов на месте. Правильный ответ - <text class="hidden">бонус каска $0089 у первого игрока и $008A у второго игрока, бонус часы - $0100.</text>
</p>

<a name="019"></a><h2>Координаты танков</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
В действительности любой объект в играх сам по себе размером в 1 пиксель, его положение в игровой вселенной определяется координатами по оси X (горизонталь), оси Y (вертикаль), и иногда оси Z (высота). Координаты X - адреса $0090-$0097. X увеличивается при движении вправо и уменьшается при движении влево. Первые 2 адреса выделены для первого и второго игрока, остальные 6 для врагов. Координаты Y - адреса $0098-$009F по аналогичному принципу. Y увеличивается при движении вниз и уменьшается при движении вверх.
</p>

<p>
Вокруг того самого пикселя объекта рисуется его графика исходя из координат. С координатами также связаны хитбоксы (размер области вокруг объекта, при соприкосновении с которой в игре засчитывается касание) и коллизии (столкновение объекта с препятствиями наподобие стены и потолка). А еще они нужны для правильного отображения объекта на экране относительно камеры. В Battle City все уровни умещаются в один экран, поэтому для хранения координат объектов достаточно по одному адресу для X и Y. Но в играх, где главный герой перемещается по длинным уровням, то есть где присутствует скроллинг экрана, и особенно когда игра умеет запоминает объекты вне видимого экрана, одного адреса уже недостаточно для хранения координаты. Игра будет хранить ее сразу в двух адресах, имитируя 16-битное число, то есть обязательно должен существовать старший байт координаты.
</p>

<div class="tip">
<p>
В некоторых играх у тебя не будет получаться вручную изменить байт в адресе координат без заморозки, байт будет автоматически перезаписан. Скорее всего это означает что ты копаешься не в главном адресе координат, а во второстепенном, который может выглядеть так же, но служить для другой цели. Поскольку кроме RAM игре больше негде хранить текущие координаты, тебе следует поискать получше. В Battle City заменить координаты удается без труда, так что ты можешь переместить танк игрока или врага в любую точку экрана, даже туда, куда физически невозможно заехать.
<br>
<br>
<img src="../../images/158.png">
<br>
<br>
Если менять байт в нужном адресе, объект должен телепортироваться, а если заморозить, объект должен потерять возможность двигаться по соответствующей оси. Фиксировать объект в какой-то точке при помощи заморозки бывает очень полезно для тестирования кода и игрового процесса. Или же просто заморозить врага в одной точке, чтобы тот не мешался под ногами пока ты двигаешься своим персонажем.
<br>
<br>
Если в коде подкрутить проверку координат, можно сделать объект неуязвимым (физически прозрачным) для врагов и <text class="object">прожектайлов</text>, а также игнорировать любые коллизии (проходить через стены) или же наоборот добавить их (пробегать через ямы по невидимому мосту). Прожектайл (projectile) - предмет, выпущенный в противника с дальнего расстояния и наносящий урон при касании, например пули в Battle City или огненные шары у Mario.
</p>
</div>

<p>
Скорость передвижения объектов оценивается в пикселях, пройденных за кадр. Но целый пиксель сам по себе является довольно большой еденицей для скорости, то есть два объекта со скоростью в 1 и 2 пикселя за кадр будут слишком медленные/слишком быстрые относительно друг друга. А ведь в играх бывают ускорения, замедления, да и вообще различные скорости у разных объектов, и все это выглядит очень плавно. Для этого выделяются дополнительные адреса, отвечающие за дробную часть пикселя. Отобразить такое движение на часть пикселя игра не сможет, но на длительном промежутке можно заметить разницу в скорости, например при сравнении одновременно двух объектов со скоростью в 1 пикселей за кадр у первого и 1,25 у второго.
</p>

<div class="tip">
<p>
В Battle City скорость устроена по-другому. У танков есть 3 типа скорости. Самые медленные это враги за 100, 300 и 400 очков. Средний по скорости это танк игрока, а самый быстрый - враг за 200 очков. 
<br>
<br>
<img src="../../images/014.png">
<br>
<br>
Самые медленные враги обновляют свои координаты через кадр - один кадр стоят на месте, второй кадр двигаются, и в итоге получается скорость в среднем 0,5 пикселя за кадр. Танк игрока передвигается 3 кадра и стоит неподвижно 1 кадр, что в среднем равно 0,75 пикселей за кадр. 200-очковый танк двигается ежекадрово, то есть ровно 1 пиксель за кадр. Ты можешь сам в этом убедиться, если будешь покадрово проматывать игру горячей клавишей <text class="button">Frame Advance</text>. А чтобы протестировать свой танк, удерживай кнопку движения (или заморозь нужный байт в $0006) пока жмешь горячую клавишу.
</p>
</div>

<p>
Твой танк может стрелять по 2 пули если взять минимум 2 бонуса со <text class="object">звездой</text>. Попробуй самостоятельно найти адреса с координатами пуль X и Y первого и второго игрока. Чтобы лишняя информация в RAM тебя не отвлекала, придумай как можно избавиться от врагов. Правильный ответ - <text class="hidden">Запиши #00 в $007F для предотвращения респауна новых врагов. X пуль первого игрока $00B8 и $00C0, второго игрока $00B9 и $00C1. Y пуль первого игрока $00C2 и $00CA, второго игрока $00C3 и $00CB.</text>
</p>

<div class="tip">
<p>
Скорость пуль, в отличие от танков, определяется типом танка, которым она была выпущена. Например если выбить бонус со <text class="object">звездой</text> когда твой танк без прокачки, затем выстрелить пулю, и поднять бонус пока пуля еще летит, то уже летящая пуля не поменяет свою текущую скорость, но твоя следующая выпущенная пуля будет быстрее благодаря прокачке танка. Можно сделать вывод, что где-то в RAM отдельно хранится информация о скорости каждой выпущенной пули, то есть она не зависит от типа танка когда <text class="underline">уже</text> находится в полете.
</p>
</div>

<a name="020"></a><h2>Координаты в Super Mario Bros</h2>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Я считаю что координаты требуют наглядного примера посложнее, чем Battle City, поэтому возьмем для разбора <text class="file">Super Mario Bros. (W) [!].nes</text> (скачай по прямой <a href="../../files/Super Mario Bros. (W) [!].nes" target="blank">ссылке</a>). Эта игра возможно не самый удачный пример, но как и Battle City ее все знают, и очень много ромхакеров начинают с нее (может ты один из них?), об этом говорят тысячи хаков по этой игре.
</p>

<p>
Начнем с позиции по вертикали. Младший байт координаты Y хранится в адресе $00CE. Координата будет уменьшаться во время прыжка и увеличиваться при падении. В Super Mario Bros отсчет идет от начальной координаты #00, которая находится сразу под статусбаром (область на экране, где в играх отображены очки, таймер времени, количество жизней и прочее). Если заморозить байт в адресе $00CE, Марио не сможет падать и перепрыгивать препятствия, потому что его положение по вертикали будет зафиксировано в одной точке.
</p>

<div class="tip">
<p>
Обычно в играх координата Y = #00 находится в самом верху экрана, а точнее на 8 пикселей выше видимого верхнего края экрана, поскольку эмулятор по умолчанию не отображает эти 8 пикселей для региона NTSC. Отображение можно изменить в настройках видео (<text class="path">Config -> Video</text>), поменяв значение на 0. После ознакомления лучше вернуть обратно значение 8.
<br>
<br>
<img src="../../images/160.png">
</p>
</div>

<p>
Старший байт координаты Y находится в адресе $00B5. Вместе с адресом $00CE они симулируют 16-битное число. По умолчанию в $00B5 записано #01. Это сделано специально, с запасом, чтобы если Марио вдруг залезет на статусбар, игра смогла без проблем продолжать уменьшать 16-битное число. Если Марио прыгнет слишком высоко и пересечет ту самую линию $00CE = #00, например подпрыгнув с ящика в начале уровня 1-1, младший байт в $00CE продолжит уменьшаться по кругу, а старший байт в $00B5 станет = #00.
</p>

<p>
<img src="../../images/159.png">
</p>

<div class="tip">
<p>
Когда Марио падает в яму, игра засчитывает смерть как только старший байт координаты Y в $00B5 будет = #02. Если записать туда #02, смерть персонажа будет мгновенная. А если заморозить байт #01 и прыгнуть в яму, Марио будет бесконечно падать и появляться под статусбаром, потому что заморозка не позволяет старшему байту Y увеличиваться, ограничивая перемещение Марио по вертикали в фиксированных 256 пикселях.
</p>
</div>

<p>
Дополнительную корректировку к координатам Y добавляет байт из адреса $0416. Этот байт симулирует дробную часть у 16-битного числа, прибавляя к пиксельным координатам какую-то часть от целого пикселя. Например если $00B5 = #01, $00CE = #B0, а $0416 = #40, координата Марио по Y равняется 432,25 пикселя (1*256 + 176 + 64/256). Адрес $0416 помогает регулировать количество пикселей за кадр с точностью в 1/256 часть пикселя.
</p>

<p>
Теперь рассмотрим скорость, с которой будет изменяться координата Y. За скорость перемещения Марио по вертикали отвечают $009F и $0433, с помощью них создается физика гравитации. Основной адрес это $009F, во время прыжка туда изначально записывается #FC. А если Марио максимально разгонится (с удержанием кнопки <text class="button">B</text>), то запишется #FB, и тот подпрыгнет еще выше. Код добавляет скорость из $009F к младшему байту координаты $00CE, что заставляет уменьшаться/увеличиваться координату объекта. А если координата переходит на другую страницу из 256 пикселей, корректируется старший байт $00B5.
</p>

<p>
$0433 это дополнительный адрес скорости, он помогает изменять $009F, создавая более плавный эффект гравитации. Если заморозить в нем байт #00, то во время прыжка $009F не будет изменяться, что приведет к бесконечному полету/падению. В то же время байт из $0433 складывается с байтом в $0416, отвечающем за дробную часть координаты по вертикали.
</p>

<div class="tip">
<p>
Для слежения за несколькими адресами RAM одновременно используй <text class="path">Tools -> RAM Watch</text>. В будущем сможешь подробнее прочитать про окно RAM Watch, хотя пользоваться им очень легко и без инструкции.
</p>
</div>

<p>
С координатами X по горизонтали в целом то же самое, что и с Y, но есть и отличия. Младший байт X хранится в $0086, старший - в $006D, а дробная часть пикселя - в $0400. За скорость смещения по горизонтали отвечает лишь один адрес - $0057. В этой игре есть физика разгона, когда Марио постепенно набирает скорость после начала движения. Максимальный байт в $0057 во время движения вправо/влево #18/#E8 при ходьбе и #28/#D8 при беге. Этот адрес одновременно является и таймером разгона, и скоростью смещения по горизонтали. В игре существует участок кода, где байт из этого адреса проходит через фильтр арифметических вычислений. И в зависимости от того, насколько сильно разогнался Марио, определяется итоговая скорость смещения в целых и дробных пикселях, которая будет влиять на адреса с координатами Марио по горизонтали.
</p>

<div class="tip">
<p>
Чтобы убедиться что адрес со скоростью смещения найден правильно, иногда достаточно заморозить там какой-то байт для подтверждения. Если игра не проверяет удержанные кнопки игрока для движения, а просто считывает адреса скоростей, объект должен начать самостоятельно смещаться пока байт заморожен. Причем чаще всего сторона, в которую повернут объект, не изменится, а сам объект начнет неподвижно передвигаться с указанной скоростью. Адреса скоростей с дробными пикселями обычно не считываются кодом для экономии ресурсов процессора, если в адресах со скоростями целых пикселей записано #00.
<br>
<br>
В игре Super Mario Bros автоматически воспроизводится анимация движения по горизонтали даже без удержания кнопки направления, если в $0057 находится что-то кроме #00. Если заморозить достаточно высокий разгон, Марио начнет пробегать сквозь препятствия, немного замедляясь когда игра будет пытаться его оттуда вытолкнуть.
<br>
<br>
Если баловаться с $009F, можно заставить Марио бесконечно подлетать, нужно заморозить к примеру байт #FF, это позволит ему проходить сквозь потолки. А чтобы провалиться через пол, потребуется скорость побольше, минимум 5 пикселей за кадр, предварительно заморозив #01 или #02 в $001D, сообщив игре что Марио сейчас якобы в состоянии прыжка или падения с платформы.
</p>
</div>

<a name="004"></a><p class="subtitle">Карта NES Memory</p>
<p>
<a href=#000>Назад к содержанию</a>

<h2>Карта RAM</h2>

<p>
Вот типичная карта памяти основной RAM для большинства игр:
</p>

<p>
<li><strong>$0000-$00FF</strong> - нулевая страница памяти (Zero Page). Это самые ценные адреса во всей RAM, поскольку обращение к ним занимает у процессора меньше времени, чем ко всем остальным, поэтому игры обычно располагают здесь наиболее важные и часто используемые данные. Адреса с кнопками джойстиков почти наверняка будут здесь.</li>
<li><strong>$0100-$01FF</strong> - адреса <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA" target="blank">стека</a>, необходимые в первую очередь для хранения адресов возврата из подпрограмм. Стек <text class="underline">всегда</text> будет находиться по этим адресам во всех играх, про него поговорим в разделе с командами процессора.</li>
<li><strong>$0200-$02FF</strong> - чаще всего игры хранят здесь атрибуты <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D1%80%D0%B0%D0%B9%D1%82_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0)" target="blank">спрайтов</a>, и в Battle City тоже. Эти адреса очень легко найти по внешнему виду, особенно когда на экране много движущихся объектов. Для спрайтов <text class="underline">всегда</text> выделено 16 строчек. Подробнее узнаешь в разделе с графикой.</li>
<li><strong>$0300-$06FF</strong> - тут может быть что угодно, обычно это адреса с координатами объектов и прочие их характеристики. Данные уровня тоже чаще всего расположены в этом диапазоне.</li>
<li><strong>$0700-$07FF</strong> - здесь могут быть адреса, выделенные для игрового музыкального движка. Такие адреса в принципе тоже легко находимы, если просто стоять в игре на месте, слушать музыку и просматривать RAM.</li>
</p>

<p>
Адреса $0200-$07FF представляют собой одинаковую ценность, поэтому игры обычно хранят здесь что-то второстепенное. В Battle City музыка находится в $0300-$03FF, а $0400-$07FF это данные уровня (кирпичи, вода и все остальное).
</p>

<h2>Прочие адреса</h2>

<p>
А теперь быстренько рассмотрим оставшиеся адреса $0800-$FFFF для общего сведения:
</p>

<p>
<li><strong>$0800-$1FFF</strong> - основная RAM $0000-$07FF зеркалится 3 раза подряд из-за каких-то особенностей процессора NES. Точно не знаю в чем причина, вроде бы процессор обрабатывает лишь первые 11 бит у 16-битного адреса RAM, а остальные 5 игнорирует. <strong>$0000</strong> = $0800 = $1000 = $1800, <strong>$0001</strong> = $0801 = $1001 = $1801, и так далее. Когда что-то записывается в оригинальную RAM, это отображается и в зеркалах, причем если записать в одно из зеркал, то это отобразится в оригинале и в двух других зеркалах. Но тебе предстоит работать только с оригиналом.</li>
</p>

<div class="tip">
<p>
Применение адресов $0800-$1FFF для своих целей возможно только на модифицированном эмуляторе, который удаляет эмуляцию зеркал, тем самым освобождая еще +6 килобайт RAM. Однако такие хаки не будут работать на обычных эмуляторах и на железе (оригинальной приставке). В будущем ты сможешь почитать статьи на эту тему, а также о других возможностях такой модификации.
</p>
</div>

<p>
<li><strong>$2000-$2007</strong> - 8 регистров видеопроцессора. Через адресные регистры процессор общается с другими составляющими приставки, в данном случае с видеопроцессором.</li>
<li><strong>$2008-$3FFF</strong> - зеркала регистров видеопроцессора.</li>
<li><strong>$4000-$4017</strong> - регистры аудиопроцессора и джойстиков.</li>
<li><strong>$4018-$401F</strong> - какие-то <a href="https://wiki.nesdev.com/w/index.php/CPU_Test_Mode" target="blank">незадействанные</a> регистры. Они тебе не понадобятся.</li>
<li><strong>$4020-$5FFF</strong> - в зависимости от <a href="http://tv-games.ru/wiki/Articles/NESMappers.html" target="blank">маппера</a> могут служить регистрами для различных целей, например регистры дополнительных музыкальных каналов.</li>
<li><strong>$6000-$7FFF</strong> - батарейка, чаще всего используется <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%80%D0%BE%D0%BB%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0" target="blank">RPG-играми</a> для сохранения игрового процесса. Если у твоей игры подходящий маппер, можно подключить батарейку и получить еще +8 килобайт памяти, которые можно использовать как дополнительную RAM, а также для хранения кода/данных.</li>
<li><strong>$8000-$FFFF</strong> - здесь расположены байты из <text class="path">View -> ROM File</text>, которые в данный момент загружены в NES Memory. Тут можно найти игровой код, а также различные байты данных, которые затем могут быть записаны в RAM, например скорость объектов, высота прыжков, музыка, текст, палитра, и многое другое. Область $8000-$FFFF размером всего 32 килобайта. Поскольку процессор NES умеет обращаться только к адресам в диапазоне $0000-$FFFF, а большинству крупных игр для работы не достаточно 32 килобайта памяти (и ROM'ы вполне могут быть больше по размеру, чем 32 килобайта), игры используют так называемое переключение <text class="object">банков</text>, а метод и возможность переключения зависят от маппера.</li>
</p>

<div class="tip">
<p>
Банк - страница памяти NES Memory размером 8, 16 или 32 килобайта в диапазоне $8000-$FFFF. У мапперов могут быть несколько таких переключаемых банков отдельно друг от друга, а также фиксированные банки памяти без возможности переключения. Еще могут существовать банки тайлов для видеопамяти размером от 1 до 8 килобайт.
<br>
<br>
Коротко о переключении банков. Если у маппера есть такая функция, то через особые регистры этого маппера можно мгновенно подгрузить новый участок (банк) памяти из <text class="section">ROM File</text> в выбранный банк NES Memory. Когда в игре очень много кода и данных, игра не в состоянии хранить все лишь в одном банке как в Battle City, и у нее не остается иного выбора кроме как подключить другой банк с новым кодом и данными. Поэтому очень часто узкоспециализированные масштабные программы, напрямую не зависящие друг от друга, например анимация объектов, вычисление физики или музыкальный движок, находятся в раздельных банках и подключаются по очереди на протяжении кадра в том порядке, в каком запрограммирован основной игровой скрипт.
<br>
<br>
В зависимости от маппера, некоторые адреса из $8000-$FFFF могут одновременно являться и памятью (код/данные), и регистрами, в частности для переключения банков.
<br>
<br>
Иногда можно относительно легко перевести игру с одного маппера на другой, чтобы воспользоваться его преимуществами.
</p>
</div>

<a name="005"></a><p class="subtitle">Заключение</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Все RAM адреса Battle City, про которые я тебе рассказал в этой статье, достаточно примитивные, ты и сам без особого труда смог бы определить их значение. С расшифровки RAM и начинается изучение игры, над которой ты хочешь поработать. Если ты задумал сделать что-то простое, вроде увеличения количества жизней в какой-то игре, тебе достаточно найти пару нужных адресов. А если же ты запланировал какую-то относительно глобальную модификацию, тебе следует изучить игру получше, это очень сильно поможет. Во-первых, расшифровка адресов значительно упрощает чтение кода. Во-вторых, зная как можно больше игровых адресов, ты сможешь найти сразу несколько решений твоей проблемы (написание кода). В-третьих, ты будешь лучше понимать к каким желаемым или негативным последствиям приведет редактирование кода игры.
</p>

<p>
В дальнейшем ты сможешь почитать отдельную статью об эффективных способах поиска адресов, о существовании которых тебе известно, но определить их местоположение затруднительно. А пока твоим домашним заданием будет расшифровать как можно больше адресов RAM в своей игре, которую ты хочешь хакнуть. Поставь себя на место разработчика игры и подумай как именно бы ты хранил что-то в RAM. У некоторых адресов может быть сразу несколько предназначений. И отметь возможные свободные адреса, в будущем они могут тебе понадобиться для написания собственного кода и хранения своих новых игровых данных.
</p>

<p>
Если игра достаточно популярна, наверняка в интернете уже есть информация по некоторым ее адресам. Свою игру попробуй найти на Romhacking.net (RHDN) на <a href="https://www.romhacking.net/hacks/" target="blank">этой</a> странице в списке <text class="section">Game</text>. Например вот так выглядит страница для <a href="https://www.romhacking.net/games/777" target="blank">Battle City</a>. На таких можно найти документы по данной игре, посмотреть список специальных программ (утилит) для нее, узнать о существующих переводах и хаках. Если тебе повезет, будет иметься полезная ромхакеру информация, такая как карта адресов RAM (<text class="section">RAM Map</text>), ее содержат на викистраницах сайта <a href="https://datacrystal.romhacking.net/wiki/Category:NES_games" target="blank">Data Crystal</a> (вероятно есть и другие похожие сайты). Если ты ничего не нашел, или у тебя возникают трудности по игре, свяжись с авторами хаков, возможно у них остались какие-то заметки, и они с радостью с тобой поделятся, будь уверен.
</p>

<p>
Если тебя заинтересовала игра Battle City, можешь почитать по ней <a href="https://habr.com/ru/post/142126" target="blank">эту статью</a> на досуге.
</p>

<br>
<hr>
<br>

<div id="sigCommentsBlock"></div>
<a href="http://sigcomments.com" style="font-size: 0.6em;">Система комментирования SigComments</a>
<script type="text/javascript">
	(function(){
		var host_id = '3239';
		var script = document.createElement('script');
		script.type = 'text/javascript';
		script.async = true;
		script.src = '//sigcomments.com/chat/?host_id='+host_id;
		var ss = document.getElementsByTagName('script')[0]; 
		ss.parentNode.insertBefore(script, ss);
	})();
</script>

</body>

</html>