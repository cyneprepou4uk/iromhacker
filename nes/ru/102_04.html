<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Debugger и ROM File</title>
<link rel="icon" href="../../favicon.png" type="image/png">

<!-- https://metrika.yandex.ru -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
   ym(54055780, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/54055780" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- https://metrika.yandex.ru -->

<link href="../../css_js/page_style.css" rel="stylesheet">

<!-- https://sorgalla.com/lity/ -->
<link href="../../css_js/lity.css" rel="stylesheet">
<script src="../../css_js/jquery.js"></script>
<script src="../../css_js/lity.js"></script>

<script id="chatBroEmbedCode">/* Chatbro Widget Embed Code Start */function ChatbroLoader(chats,async){async=!1!==async;var params={embedChatsParameters:chats instanceof Array?chats:[chats],lang:navigator.language||navigator.userLanguage,needLoadCode:'undefined'==typeof Chatbro,embedParamsVersion:localStorage.embedParamsVersion,chatbroScriptVersion:localStorage.chatbroScriptVersion},xhr=new XMLHttpRequest;xhr.withCredentials=!0,xhr.onload=function(){eval(xhr.responseText)},xhr.onerror=function(){console.error('Chatbro loading error')},xhr.open('GET','//www.chatbro.com/embed.js?'+btoa(unescape(encodeURIComponent(JSON.stringify(params)))),async),xhr.send()}/* Chatbro Widget Embed Code End */ChatbroLoader({encodedChatId: '83WQ5'});</script>

</head>

<body>

<h1>Debugger и ROM File</h1>
<p>
<a href="https://romhacking.github.io/nes/index_ru.html" target="blank">Вернуться на главную страницу</a>
</p>

<p>
Из прошлой статьи ты узнал, что в Battle City адрес $0051 отвечает за количество жизней 1-го игрока. Чтобы у игрока вообще появились жизни, игра должна была в какой-то момент записать туда байт с количеством жизней (#03). Если ромхакер хочет изменить начальное количество, ему нужно найти код, который делает запись в адрес $0051. Сейчас ты научишься ловить игру с поличным на этом действии, а также изменять начальное количество жизней игрока. В статье ты узнаешь про некоторые команды процессора, более подробно про них будет рассказано в соотсветствующем разделе.
</p>

<a name="000"></a><p class="title">Содержание</p>

<ul>
<li><a href=#001>Debugger</a></li>
<li><a href=#002>Breakpoint'ы</a></li>
<li><a href=#003>Комментарии</a></li>
<li><a href=#004>Первый хак</a></li>
<li><a href=#005>Другие способы изменить байт</a></li>
<li><a href=#006>Тестирование кода</a></li>
<li><a href=#007>Прочие виды Breakpoint'ов</a></li>
<li><a href=#008>Содержимое ROM File</a></li>
<li><a href=#009>Заключение</a></li>
</ul>

<a name="001"></a><p class="subtitle">Debugger</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Я уже говорил о том, что ROM сам по себе это просто набор байтов. <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BB%D0%B0%D0%B4%D1%87%D0%B8%D0%BA" target="blank">Debugger</a> (отладчик кода) интерпретирует эти байты в инструкции (команды) процессора NES. В играх находится очень много кода, и за 1 кадр процессор выполняет тысячи инструкций. Но просматривать весь игровой код почти никогда не имеет смысла, чаще всего тебя интересует лишь какой-то отдельный небольшой участок, отвечающий за опеределенную задачу. Debugger позволяет остановить эмуляцию игры с хирургической точностью и посмотреть на тот самый участок. Проще говоря, ты сможешь очень быстро найти код с записью начальных жизней. В эмуляторе FCEUX замечательный отладчик, хоть и не без косяков.
</p>

<p>
Debugger вызывается через <text class="path">Debug -> Debugger</text> (или горячей клавишей).
</p>

<p>
<img src="../../images/017.png">
</p>

<p>
Окно на первый взгляд возможно выглядит довольно устрашающим для новичка, но ты быстро в нем освоишься. Все байты из адресов $0000-$FFFF, расположенных в <text class="path">Hex Editor -> View -> NES Memory</text>, будут отображены как команды процессора. После ознакомления окно можешь закрыть, пока что оно тебе не понадобится.
</p>

<p>
<a class="data-lity" href="../../images/018.png" data-lity><img height="200" src="../../images/018.png"></a>
</p>

<div class="tip">
<p>
В подавляющем большинстве случаев в диапазоне $0000-$7FFF не будет никакого кода, лишь RAM и прочие адреса, байты в которых Debugger пытается интерпретировать как код. Поэтому будем считать за местоположение кода лишь диапазон $8000-$FFFF.
</p>
</div>

<a name="002"></a><p class="subtitle">Breakpoint'ы</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Основным оружием в Debugger'е для поиска нужного кода являются <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D1%87%D0%BA%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B0" target="blank">Breakpoint'ы</a> (брейк поинт - точка останова, или бряк). Точка останова - это условие, при выполнении которого остановится программа (эмулятор), то есть останавливается выполнение кода программы (игры). Breakpoint'ы можно создавать вручную через окно Debugger'а, но к этому мы вернемся позднее. Для адресов RAM обычно быстрее и удобнее создавать их через Hex Editor.
</p>

<p>
Чтобы отследить код с записью в некий адрес RAM, нужно выполнить подготовительных 3 шага:
</p>

<p>
<ol>
<li>Найти интересующий нас адрес, на который мы позже будем ставить Breakpoint чтобы поймать игру на записи в этот адрес. Если мы не знаем адрес, мы не сможем найти код. Чем больше адресов в игре тебе известно, тем больше кода ты сможешь найти и распознать его значение. Это работает и в обратную сторону - чем больше кода ты смог расшифровать, тем больше ты сможешь узнать о неизвестных тебе игровых адресах. А чем большей информацией об игре ты владеешь, тем более глобальные изменения ты сможешь в нее привнести. Адрес с жизнями в Battle City мы уже определили - это $0051, который хранит жизни 1-го игрока.</li>
<li>Выяснить когда именно в игре будет сделана запись в этот адрес. Если байт #03 уже находится в $0051, загрузи более ранние сохранения или запусти игру сначала (в идеале через <text class="button">Hard Reset</text> для предварительной очистистки RAM), затем продолжай играть, время от времени сохраняясь, до тех пор пока не увидишь что в $0051 появился байт #03. В Battle City жизни будут записаны в момент перехода из главного экрана на экран выбора уровня. Однако есть еще один не самый очевидный случай, это когда игра из главного меню автоматически переходит в демо-режим, в котором у обоих игроков также по 3 жизни.</li>
<li>Бессмысленно пытаться подловить игру на записи, когда эта запись уже была когда-то совершена. Ведь если жизни уже были записаны, то отследить код, сделавший это, ты уже не сможешь. Поэтому мы подбираемся к такому игровому моменту, когда этого еще не случилось, но уже скоро случится. В более сложных случаях нужно будет подкрасться на 1-2 кадра до записи в адрес, чтобы упростить себе поиск кода. В нашем случае досаточно находиться в главном меню.</li>
</ol>
</p>

<p>
Приступим. Сначала сделай <text class="button">Hard Reset</text> горячей клавишей, это автоматически обнулит все адреса RAM, включая $0051. Дождись когда главное меню зафиксируется на месте (можешь ускорить его прокрутку кнопкой <text class="button">Start</text>), режим игры оставь 1 Player, сделай сохранение и поставь эмулятор на паузу (пауза не обязательна, просто нужно успеть создать Breakpoint до перехода игры в демо-режим). Теперь кликни в Hex Editor'е правой кнопкой мыши на адресе $0051 и выбери <text class="section">Add Write Breakpoint</text>.
</p>

<p>
<a class="data-lity" href="../../images/019.png" data-lity><img height="200" src="../../images/019.png"></a>
</p>

<p>
<text class="object">Write</text> означает запись. То есть ты ставишь условие для Debugger'а остановить игру в том случае, когда код игры будет пытаться что-то записать в $0051. После клика по Add Write Breakpoint автоматически откроется Debugger, и справа вверху ты увидишь свою созданную точку останова.
</p>

<p>
<img src="../../images/020.png">
</p>

<p>
В ее описании указаны следующие данные:
</p>

<p>
<li><text class="object">$0051</text> - адрес, на который ты выставил условие для остановки.</li>
<li>Буква <text class="object">E</text> - <text class="object">E</text>nable (активирован), значит что условие активно. Двойным кликом по этому Breakpoint'у можно активировать/деактивировать его.</li>
<li>Буква <text class="object">C</text> - <text class="object">C</text>pu Memory (память процессора), то есть условие на адрес из NES Memory.</li>
<li>Буква <text class="object">W</text> - <text class="object">W</text>rite (запись) - тип условия.</li>
</p>

<p>
Теперь сними эмулятор с паузы и нажми кнопку <text class="button">Start</text> для попытки перейти на экран с выбором уровня. Эмулятор автоматически поставится на паузу, а окно Debugger'а станет активным, значит условие Breakpoint'а выполнилось. Промотай код чтобы выглядело примерно как у меня на картинке, ориентируйся по адресу $C2CF рядом со <text class="object">стрелочкой</text> слева.
</p>

<p>
<a class="data-lity" href="../../images/021.png" data-lity><img height="200" src="../../images/021.png"></a>
</p>

<div class="tip">
<p>
Эмулятор сейчас стоит на паузе после срабатывания Breakpoint'а, однако красный значок паузы в главном окне не отображается. Это происходит только при оставноке игры Debugger'ом. Такая путаница в будущем может стоить тебе ошибок при работе с игрой. Рекомендую включить отображение FPS в эмуляторе (<text class="path">Config -> Display -> FPS</text>), если ты этого еще не сделал, это поможет тебе лучше ориентироваться и случайно не нажать ничего лишнего. Когда ты ставишь паузу горячей клавишей, FPS опустится до 20, а если пауза стоит из-за Debugger'а, счетчик будет неподвижен и иметь другое числовое значение. Если ты только сейчас включаешь отображение FPS пока эмулятор стоит на паузе, счетчик появится на экране лишь на следующем кадре.
</p>
</div>

<p>
При помощи Write Breakpoint'а мы выловили момент <text class="underline">попытки</text> записи чего-то в $0051, но этого <text class="underline">еще не произошло</text>. Чуть выше стрелочки можно увидеть команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$03</span>, которая расшифровывается как <text class="object">L</text>oa<text class="object">D</text> <text class="object">A</text>ccumulator with memory (загрузить что-то в регистр <text class="object">A</text>).
</p>

<p>
<img src="../../images/161.png">
</p>

<p>
Содержимое регистра <text class="object">A</text> в данный момент (во время паузы эмулятора после срабатывания Breakpoint'а) можно увидеть в Debugger'е справа вверху, рядом с другими двумя регистрами - <text class="object">X</text> и <text class="object">Y</text>.
</p>

<p>
<img src="../../images/022.png">
</p>

<p>
Процессор NES не умеет передавать что-либо куда-либо без посредников, и в качестве посредника он использует один из своих регистров, в данном случае это <text class="object">A</text> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BA%D0%BA%D1%83%D0%BC%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80_(%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0)" target="blank">аккумулятор</a>). Debugger показывает, что сейчас в него загружен байт #03, который попал туда после выполнения команды <span class="debugger_color_blue">LDA $</span><span class="debugger_color_green">#03</span>. Поскольку процессор выполняет команды по порядку сверху вниз, мы можем быть уверены в том, что команда <span class="debugger_color_blue">LDA $</span><span class="debugger_color_green">#03</span> уже была выполнена до срабатывания нашего Breakpoint'а, и на данный момент стрелочка в Debugger'е ждет выполнения следующей команды - <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$51</span>.
</p>

<p>
<img src="../../images/024.png">
</p>

<p>
Команда <span class="debugger_color_blue">STA</span> расшифровывается как <text class="object">ST</text>ore <text class="object">A</text>ccumulator in memory (записать байт из регистра A в какой-то адрес). Все довольно просто - процессор загрузил байт #03 в регистр A, и теперь хочет записать его в $0051. Не будем заставлять его ждать. Нажми 1 раз кнопку <text class="button">Step Into</text> справа вверху. Задача этой кнопки - выполнить команду, на которой остановилась стрелочка.
</p>

<p>
<img src="../../images/025.png">
</p>

<p>
После нажатия кнопки выполнится команда <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$51</span>, и теперь в $0051 находится байт #03. Это можно увидеть в Debugger'е и в Hex Editor'е.
</p>

<p>
<img src="../../images/026.png">
</p>

<p>
Теперь стрелочка ждет выполнения следующей по списку команды - <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$52</span>. Нетрудно догадаться, что сейчас планируется запись байта из регистра A в $0052 (жизни 2-го игрока).
</p>

<p>
<img src="../../images/027.png">
</p>

<p>
Снова нажми 1 раз кнопку <text class="button">Step Into</text> чтобы выполнить эту команду.
</p>

<a name="003"></a><p class="subtitle">Комментарии</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Глядя на незнакомый участок кода, сложно понять его значение для игры, если не знаешь за что отвечают адреса RAM, указанные в командах (даже если тебе известно как работают эти команды). Сделаем наш найденный участок более понятным. В Hex Editor'е кликни правой кнопкой мыши на $0051 и выбери <text class="section">Add symbolic debug name</text> (добавить комментарий).
</p>

<p>
<img src="../../images/028.png">
</p>

<p>
В открывшемся окне в поле ввода <text class="section">Name</text> пропиши "жизни игрока *1" (или как тебе больше нравится), и нажми <text class="button">OK</text>. Если захочешь отредактировать текст, ты всегда сможешь повторно кликнуть на <text class="section">Add symbolic debug name</text>.
</p>

<p>
<img src="../../images/029.png">
</p>

<div class="tip">
<p>
При добавления комментария через Hex Editor эмулятор автоматически ставится на паузу (не знаю почему так сделано), но он уже у тебя на паузе, поэтому ты этого не заметишь.
</p>
</div>

<p>
Аналогично добавь имя адресу $0052 - "жизни игрока *2". А также найди адрес $0083 и запиши ему "режим игры". Когда все сделаешь, кликни на окно Debugger'а и посмотри как теперь выглядит код.
</p>

<p>
<img src="../../images/030.png">
</p>

<p>
Сейчас все смотрится намного понятнее. И теперь везде, где в Debugger'е будут встречаться эти 3 адреса, которые ты переименовал, они будут подписаны человеческим языком. В качестве бонуса эти имена адресов будут отображаться в окне Hex Editor'а после клика по ним.
</p>

<p>
<img src="../../images/032.png">
</p>

<div class="tip">
<p>
Отображение комментариев в Debugger'е можно включать/отключать галочкой <text class="object">Symbolic debug</text> справа внизу. Это также повлияет на отображение комментариев в Hex Editor'е.
<br>
<br>
<img src="../../images/063.png">
<br>
<br>
Комментарии хранятся в одноименных с ROM'ом <text class="file">.nl</text> файлах. При добавлении комментария на адрес из RAM он будет записан в файл <text class="file">.ram.nl</text>. Его содержимое можно посмотреть текстовым редактором.
<br>
<br>
<img src="../../images/036.png">
</div>

<p>
А теперь вернемся к коду в Debugger'е и посмотрим что происходит дальше. Выполни следующую команду <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$6A</span> нажатием кнопки <text class="button">Step Into</text>. Затем кликни на эмулятор и нажми горячую клавишу сохранения. 
</p>

<div class="tip">
<p>
Иногда эмулятор не отображает сообщение об успешном сохранении (и вообще любые сообщения на экране) когда работаешь с Debugger'ом. Но поверь, он его делает. И слоты для сохранения тоже выбираются. Исключением является случай, когда в дополнительных окнах эмулятора открыто еще какое-то окно, например когда в Hex Editor'е открыто окошко <text class="object">Goto</text> (<text class="button">Ctrl</text> + <text class="button">G</text>).
<br>
<br>
Я так и не понял за что отвечает адрес $006A. Он выглядит заброшенным, возможно разработчики при разработке отказались от его использования, а потом забыли или не захотели убрать команду с ним в своей финальной версии игры. Такое бывает.
</p>
</div>

<p>
Теперь у тебя есть сохранение до выполнения команды <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span>. Очень часто тебе понадобится делать такие вот сохранения перед выполнением каких-то команд чтобы протестировать код. Попробуй потихоньку проматать код дальше кнопкой <text class="button">Step Into</text>. Сначала выполнится команда <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span>, потом <span class="debugger_color_blue">BNE</span> <span class="debugger_color_green">$C2DD</span>, дальше <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$00</span> и <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$52</span>. Как видишь, игра обнулила адрес $0052, тем самым запретив второму игроку появиться на уровне. Поскольку у тебя переименован адрес $0083, ты мог догадаться, что игра проверяет на режим. Игра не просто так считала адрес $0083, ей было нужно узнать какой там байт, чтобы понять что делать дальше. И сейчас игра обнулила $0052 потому что в главном меню был выбран режим 1 Player. То есть чуть выше по коду игра записала байт #03, а потом перезаписала его при помощи #00, и в итоге $0052 = #00. Код, который проверит адрес $0052 для попытки воскресить второго игрока в начале уровня, выполнится еще очень нескоро. А я напоминаю, что этот текущий участок кода, на который ты смотришь, лишь мизерная часть от всего того объема кода, выполняющегося за 1 кадр.
</p>

<p>
Кликни на эмулятор и загрузи сохранение горячей клавишей, а потом снова кликни на Debugger. До загрузки сохранения стрелочка остановилась на команде <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$01</span>, а после загрузки вернулась на <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span>, то есть именно на то место, где ты сохранился.
</p>

<p>
<img src="../../images/033.png">
</p>

<p>
Теперь в Hex Editor'е запиши в $0083 байт #01, как будто сейчас выбран режим 2 Players. При желании можешь сделать сохранение на другой слот, тогда у тебя будут 2 идентичных сохранения, отличаться будет только байт в адресе $0083. Попробуй опять промотать код кнопкой <text class="button">Step Into</text>. Снова выполнится команда <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span>, однако при выполнении команды <span class="debugger_color_blue">BNE</span> <span class="debugger_color_green">$C2DD</span> код уже не станет выполнять команды <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$00</span> и <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$52</span>, а перескочит их и сразу остановится на команде <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$01</span>. Очевидно, что игра прочитала байт в адресе $0083, поняла что там (якобы) режим 2 Players, поэтому не стала обнулять адрес $0052, то есть он сохранил свой байт #03, и теперь второй танк появится при загрузке уровня. Команда <span class="debugger_color_blue">BNE</span> проверяет на "результат не равен #00", и делает прыжок на тот адрес, который записан после команды <span class="debugger_color_blue">BNE</span>, в нашем случае это $C2DD.
</p>

<p>
<img src="../../images/034.png">
</p>

<p>
В первый раз прыжка на $C2DD не было, потому что в $0083 было записано #00 (режим 1 Player), и условие для прыжка "результат не равен #00" не выполнилось, поэтому код просто начал выполнять то, что было дальше по списку - обнулил жизни 2-го игрока. То есть несмотря на то, что код выполняется сверху вниз, не обязательно будут выполнены вообще все команды, которые ты видишь. Если рассматривать весь имеющийся код в игре, в нем существует множество различных условий, а также куча прыжков на разные участки кода. Например вот этот самый код с записью количества жизней. Хоть он и существует, но он не выполняется до тех пор, пока ты не нажмешь кнопку <text class="button">Start</text> в главном меню, и привело тебя на этот участок кода последовательное выполнение различных игровых условий.
</p>

<div class="tip">
<p>
Ты можешь задаться вопросом, зачем вообше обнулять жизни второго игрока, если можно было просто их не записывать? Так вот, это обнуление жизней сделано не просто так. В прошлой статье ты возможно пробовал заставить 2-го игрока появиться в режиме 1 Player, записав жизни в $0052 на экране выбора уровня. На самом деле такая ситуация вполне может случиться и без ручного вмешательства в RAM, причем таких ситуаций целых три.

<ol>
<li>Если поиграть в режиме 2 Players, и пока 2-й игрок еще жив, подорвать свою базу, то после возвращения в главное меню в $0052 все еще будет записано некое количество жизней. </li>
<li>Аналогичная первой, но касается демо-режима. В нем игра отдельно пишет #03 в $0052 чтобы на экране появилось 2 игрока.</li>
<li>Поиграть в режиме 2 Players или дождаться демо-режима, а потом сделать <text class="button">Soft Reset</text>. Battle City, как и некоторые другие игры, не обнуляют адреса RAM при загрузке игры, например чтобы сохранить рекорды очков. Количество жизней тоже сохранится.</li>
</ol>

Раработчики предусмотрели такой потенциальный баг, поэтому заходя на экран выбора уровня в режиме 1 Player, код игры проверяет режим и для подстраховки обнуляет $0052 чтобы 2-й игрок случайно не появился.
</p>
</div>

<p>
Если ты больше не ищешь кодов, которые что-то записывают в $0051, деактивируй Breakpoint двойным кликом по нему. Буква <text class="object">E</text> в описании пропадет, это значит что он деактивирован.
</p>

<p>
<img src="../../images/035.png">
</p>

<p>
Для запуска игры нажми кнопку <text class="button">Run</text> в Debugger'е, либо кликни на эмулятор и нажми горячую клавишу паузы. Если ты ничего больше не менял, то на текущий момент у тебя выбран режим 2 Players из-за твоей ручной записи в $0083, и второй игрок появится на уровне потому что в $0052 записано #03 жизни. Можешь попробовать снова загрузить свои сохранения и еще немного протестировать код и адреса, перед загрузкой поставь эмулятор на паузу чтобы поработать с Debugger'ом.
</p>

<a name="004"></a><p class="subtitle">Первый хак</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Код с записью начального количества жизней был найден и разобран, теперь давай изменять это количество жизней. Для этого нужно найти местоположение кода в ROM'е, поменять байт #03 на какой-то другой и сохранить получившийся хак. Сначала снова дай сработать Breakpoint'у $0051, активировав его, сделав <text class="button">Reset</text> и нажав <text class="button">Start</text>. После срабатывания Breakpoint'а сделай сохранение.
</p>

<p>
<img src="../../images/040.png">
</p>

<p>
Чтобы в команде <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$03</span> изменить байт #03, надо найти где в ROM'е находится этот байт. Самый быстрый способ - кликнуть правой кнопкой мыши слева от этой команды, по серой полоске окна Debugger'а. Этот способ работает только если эмулятор стоит на паузе, например как сейчас после срабатывания Breakpoint'а.
</p>

<p>
<img src="../../images/041.png">
</p>

<p>
Сразу после клика откроется окно Hex Editor'а (если оно у тебя закрыто), и тебя автоматически перебросит на место, где расположена команда <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$03</span> в <text class="path">View -> ROM File</text>. Однако окно откажется разворачиваться, если оно было предварительно свернуто.
</p>

<p>
<img src="../../images/042.png">
</p>

<p>
Ты увидишь байты #A9 и #03, которые как раз и составляют команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$03</span>.
</p>

<p>
<img src="../../images/043.png">
</p>

<p>
Дальше я думаю понятно что нужно сделать - поменять байт #03. Запиши туда например #05. Перезаписанные байты в ROM File выделены красным цветом, запись при желании можно отменить комбинацией <text class="button">Ctrl</text> + <text class="button">Z</text>.
</p>

<p>
<img src="../../images/044.png">
</p>

<p>
Кликнув на Debugger, ты увидишь что байт в команде <span class="debugger_color_blue">LDA</span> изменился.
</p>

<p>
<img src="../../images/045.png">
</p>

<p>
Но несмотря на то, что ты изменил этот байт, игра этого не знает. Дело в том, что игра уже выполняла команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$03</span> (которая теперь записана как <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span>), и в регистре A <text class="underline">уже</text> загружен байт #03.
</p>

<p>
<img src="../../images/046.png">
</p>

<p>
Поэтому нажав кнопку <text class="button">Step Into</text> или <text class="button">Run</text>, игра запишет этот самый байт #03 из регистра A, и количество жизней в итоге не изменится. Запусти игру чтобы в этом убедиться.
</p>

<p>
Теперь поставь эмулятор на паузу и загрузи сохранение. Стрелочка все также будет стоять на <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$51</span>, а в регистре A все еще #03. Местоположение этой стрелочки можно поменять вручную, оно указывается рядом с кнопкой <text class="button">Seek PC</text>.
</p>

<p>
<img src="../../images/047.png">
</p>

<p>
Сделаем так, чтобы стрелочка вернулась на команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span>, которая уже выполнялась до того как ты сделал сохранение. Для этого кликни один раз на адресе $C2CD слева от этой команды, скопируй его комбинацией <text class="button">Ctrl</text> + <text class="button">C</text>, затем дважды кликни на $C2CF возле кнопки <text class="button">Seek PC</text> и нажми <text class="button">Ctrl</text> + <text class="button">V</text> чтобы вставить скопированный адрес. Нажми на кнопку <text class="button">Seek PC</text> чтобы переместить стрелочку. Адрес можно записать и вручную, но копировать и вставлять обычно быстрее.
</p>

<p>
<a href="../../videos/007.mp4" data-lity><img src="../../css_js/video.png" width="128" height="128"></a>
</p>

<div class="tip">
<p>
Измененяя адрес возле кнопки <text class="button">Seek PC</text> на адрес команды повыше и затем нажав на нее, ты ни в коем случае не отматываешь код в обратную сторону и не отменяешь <text class="underline">уже</text> внесенные кодом изменения, то есть ты не возвращаешься назад во времени. Ты лишь сообщаешь Debugger'у откуда ему нужно продолжать выполнять следующую команду.
<br>
<br>
Функция отматывания кода в обратную сторону есть у Debugger'a эмулятора <a href="https://www.mesen.ca" target="blank">Mesen</a>. Изменения, совершенные кодом, действительно будут отменяться.
</p>
</div>

<p>
Сделай сохранение после перемещения стрелочки. Теперь ты можешь выполнить команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span>, и в регистр A запишется #05. После запуска игры на экране ты увидишь 4 жизни, а раньше было 2. Напомню что Battle City отображает количество на 1 меньше, чем записанный в адресе байт.
</p>

<p>
<img src="../../images/048.png">
</p>

<p>
Осталось только сохранить ROM с измененным количеством жизней. Для этого в Hex Editor'е жмешь вкладку <text class="section">File</text>. Есть 2 варианта сохранения.
</p>

<p>
<img src="../../images/049.png">
</p>

<p>
<li><strong>Save Rom</strong> - ты сохраняешь изменения в этот самый ROM, который у тебя сейчас запущен в эмуляторе. Твой красный байт #05 станет черным как остальные байты в ROM File, а это значит что ты не сможешь отменить изменения через <text class="button">Ctrl</text> + <text class="button">Z</text>.</li>
<li><strong>Save Rom As</strong> - ты указываешь куда сохранить этот измененный ROM. Записав ему другое имя, ты создашь новый отдельный ROM с этими изменениями. Красный байт #05 останется красным и его можно будет отменить (даже если ты перезапишешь текущий ROM).</li>
</p>

<p>
Теперь попробуй самостоятельно найти и поменять количество жизней, которое записывается в $0052 для демо-режима. Для него существует отдельный код, потому что в демо всегда должно быть 2 игрока, а участок кода, который мы рассматривали, может записать #00 в адрес $0052 если курсор стоял на режиме 1 Player, запретив появиться второму игроку. Если в главном меню ничего не нажимать, демо автоматически запускается через несколько секунд. Правильный ответ - <text class="hidden">команда LDA #$03 по адресу $C3C0.</text>
</p>

<a name="005"></a><p class="subtitle">Другие способы изменить байт</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Способ с правым кликом мыши по серой полосе в Debugger'е является самым быстрым, но в первую очередь он предназначен для перехода в нужное место в ROM File, а что дальше ромхакер будет делать с этим переходом это уже его дело. Есть еще несколько способов перехода, а также пару других способов изменить байт с количеством жизней. Загрузи твое последнее сохранение на команде <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span>.
</p>

<h2>Поиск адреса</h2>

<p>
Debugger отображает код по адресам $8000-$FFFF из NES Memory. Команда <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span> находится  по адресу $C2CD.
</p>

<p>
<img src="../../images/050.png">
</p>

<p>
Зайди в <text class="path">Hex Editor -> View -> NES Memory</text>, вызови окошко <text class="object">Goto</text> комбинацией <text class="button">Ctrl</text> + <text class="button">G</text>, запиши туда $C2CD (без префикса $). Потом кликни правой кнопкой по байту #05 и выбери <text class="object">Go Here In ROM File</text> (перейти сюда в ROM File). Тебя перекинет на местоположение байта #05 в ROM File.
</p>

<p>
<a href="../../videos/008.mp4" data-lity><img src="../../css_js/video.png" width="128" height="128"></a>
</p>

<p>
Еще один похожий способ. В Debugger'е выставь галочку ROM offsets справа внизу. 
</p>

<p>
<img src="../../images/051.png">
</p>

<p>
После этого в Debugger'е все адреса местоположений команд будут показывать адреса из ROM File, а не из NES Memory.
</p>

<p>
<img src="../../images/052.png">
</p>

<p>
Такой адрес не выделяется кликом по нему, надо вручную выделить его мышкой, потом скопировать. Поскольку это адрес напрямую из ROM File, нужно выбрать <text class="path">View -> ROM File</text>, а не NES Memory. Вызваешь окошко Goto, вводишь адрес 0x002DD (можно без префикса 0x и без лишних нулей слева) и переходишь на него.
</p>

<p>
<a href="../../videos/009.mp4" data-lity><img src="../../css_js/video.png" width="128" height="128"></a>
</p>

<div class="tip">
<p>
Все адреса из ROM File я буду записывать в статьях с префиксом <text class="object">0x</text> и пятью цифрами, чтобы отличать их от адресов NES Memory с префиксом $ и четырьмя цифрами. Адрес 0x002DD можно увидеть в названии окна Hex Editor'а, лишние нули обрезаются как обычно.
<br>
<br>
<img src="../../images/053.png">
<br>
<br>
Я предпочитаю смотреть на код с отключенной галочкой ROM offsets, потому что меня больше интересуют адреса NES Memory, а знать где находится команда в ROM File мне необходимо только при редактировании кода. Рекомендую тоже ее отключать.
</p>
</div>

<p>
Еще один способ, но он скорее для демонстрации возможности поиска в Hex Editor'е. Переходишь в <text class="path">View -> ROM File</text>. Жмешь комбинацию <text class="button">Ctrl</text> + <text class="button">F</text>, откроется окно поиска. Для поиска байтов нужно оставить <text class="object">Hex</text> в секции <text class="section">Type</text>. Секция <text class="section">Direction</text> (направление) определяет направление поиска по файлу <text class="object">Up</text> (вверх) или <text class="object">Down</text> (вниз). Начальной точкой поиска считается адрес, который указан в названии окна, то есть тот, на который ты кликал в последний раз.
</p>

<p>
<img src="../../images/163.png">
</p>

<p>
Перепишем из Debugger'а байты, из которых составляются некоторые команды, в строку для поиска. Допустим возьмем команды <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span>, <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$51</span> и <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$52</span>.
</p>

<p>
<img src="../../images/162.png">
</p>

<p>
Получится такой набор байтов - A90585518552. Пробиваем их по поиску кнопкой <text class="button">Find Next</text> (найти далее) и находим местоположение кода в ROM File. Убеждаемся что такой набор байтов встречается лишь единожды, чтобы не отредактировать какой-то другой код (об этом скажет окошко с ошибкой при попытке дальнейшего поиска), затем редактируем байт с количеством жизней и сверяемся с Debugger'ом.
</p>

<h2>Изменение байта напрямую</h2>

<p>
Не обязательно пользоваться Hex Editor'ом чтобы поменять байт, это можно делать через Debugger, однако такие изменения не хранятся в Hex Editor'е, и ты не сможешь отменить эти изменения. К тому же есть некоторые неудобства (которые я не буду описывать), если надо изменить сразу несколько байтов, а не только 1. Поэтому я все же рекомендую все делать через Hex Editor.
</p>

<p>
В Debugger'е можно вызвать окно <text class="object">Inline Assembler</text> для редактирования кода. Оно очень удобно для изменения адресов прыжков в условиях, когда ты в будущем будешь прописывать свои коды. Для начала скопируй целиком команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span> (можно копировать вместе с пробелами слева от команды если лень прицеливаться). Потом кликни левой кнопкой мыши по серой полоске слева от команды, откроется окошко Inline Assembler (команду также можно скопировать из этого же окна справа вверху). Вставь команду, поменяй байт например на #07, нажми <text class="button">Enter</text>, затем <text class="button">Apply</text> (применить), и закрой окно.
</p>

<p>
<a href="../../videos/010.mp4" data-lity><img src="../../css_js/video.png" width="128" height="128"></a>
</p>

<p>
Хоть в ROM File байт и поменяется, но эти изменения лишь временные. Для создания хака нужно дополнительно сохранить ROM через Hex Editor (<text class="path">File -> Save</text>), в противном случае при закрытии эмулятора твои изменения кода просто растворятся в воздухе.
</p>

<p>
Следующим способом я не пользуюсь, но вдруг он тебе понравится. Делается он при помощи окна <text class="object">Rom Data Editor</text>. Копируешь адрес слева от команды <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$07</span>. Жмешь кнопку <text class="button">Rom Patcher</text>. Вставляешь адрес и жмешь кнопку <text class="button">Edit This Offset</text>. Копируешь появившиеся байты и вставляешь их в поле <text class="section">Patch Data</text>. Находишь байт #07 и меняешь его например обратно на #05. Жмешь кнопку <text class="button">Apply</text>. А если нужно моментально сохранить свои изменения в ROM'е, дополнительно нажми кнопку <text class="button">Save Rom File</text>, либо опять же сохраняй через Hex Editor, по тем же причинам что и в предыдущем способе. 
</p>

<p>
<a href="../../videos/011.mp4" data-lity><img src="../../css_js/video.png" width="128" height="128"></a>
</p>

<a name="006"></a><p class="subtitle">Тестирование кода</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Иногда бывает ситуация, что при нажатии кнопки <text class="button">Step Into</text> код неожиданно прыгает в какое-то совершенно другое место без видимых причин. В Battle City это будет адрес $D400.
</p>

<!-- will make a jump to $D400 out of left field -->

<p>
<img src="../../images/037.png">
</p>

<p>
Происходит это из-за того, что кадр якобы заканчивается, и в эмулируемом процессоре NES автоматически срабатывает прерывание <text class="object">NMI</text>, код обработчика которого будет обновлять графику на экране. Я не буду это сейчас подробно описывать, тебе достаточно запомнить, что если вдруг такое случится, нужно просто загрузить сохранение и продолжать тестирование как обычно.
</p>

<h2>Подмена регистров</h2>

<p>
В главном меню выбери режим 2 Players. Потом снова дай сработать Write Breakpoint'у $0051 и сохранись.
</p>

<p>
<img src="../../images/038.png">
</p>

<p>
В прошлый раз мы вручную переместили стрелочку на команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span> для перезаписи байта в регистре A. Но есть и другой способ. Debugger позволяет тебе вручную менять те байты, которые записаны в регистрах, пока эмулятор стоит на паузе. На данный момент у тебя A = #05. 
</p>

<p>
<img src="../../images/054.png">
</p>

<p>
Запиши туда любой другой байт, например #10.
</p>

<p>
<img src="../../images/039.png">
</p>

<p>
Нажми кнопку <text class="button">Step Into</text>, и #10 запишется в $0051.
</p>

<p>
<img src="../../images/055.png">
</p>

<p>
Теперь снова поменяй байт в регистре A, скажем на #15. Нажми <text class="button">Step Into</text>, и #15 запишется в $0052.
</p>

<p>
<img src="../../images/056.png">
</p>

<p>
Нажми кнопку <text class="button">Run</text> в Debugger'е. Зайдя на уровень, у обоих игроков будет разное количество жизней.
</p>

<p>
<img src="../../images/057.png">
</p>

<div class="tip">
<p>
Такое тестирование позволяет тебе прощупать почву перед тем, как ты будешь вносить изменения байтов через Hex Editor. Допустим ты запланировал сделать каждому игроку разное количество жизней, и пережде чем писать код, ты решил сначала посмотреть что из этого получится. Конечно это довольно примитивный пример, ведь можно было просто поменять эти байты в адресах через RAM, но сама идея была в том, чтобы продемонстрировать тебе возможность это делать. В более сложных случаях это принесет тебе больше пользы. Например когда игра довольно часто что-то пишет в некий адрес, а тебе нужно подменить байт в какой-то определенный момент, и этот момент ты вылавливаешь при помощи Breakpoint'ов.
</p>
</div>

<p>
В твоих сохранениях запоминаются байты, которые на данный момент записаны в регистрах в Debugger'е. На твоем текущем сохранении A = #05. Поменяй байт на #10 и сохранись на другой слот. Теперь у тебя имеются 2 сохранения с разными количествами жизней для игроков. Чтобы в этом убедиться, загружай сохранения на паузе и сверяйся с Debugger'ом. Такой способ значительно быстрее, чем вручную туда-сюда изменять байт в Debugger'е, запускать игру и проверять что из этого получится.
</p>

<h2>Подмена флагов</h2>

<p>
Про флаги будет подробнее рассказано в разделе про команды, пока что только сам пример подмены флага. Промотай код до команды <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span> и сохранись. На данный момент у тебя режим 2 Players.
</p>

<p>
<img src="../../images/058.png">
</p>

<p>
Как ты уже знаешь, чтение байта из $0083 необходимо для возможного обнуления жизней второго игрока. Добавим побольше комментариев на этот код. Для добавления комментариев через Debugger кликай правой кнопкой мыши по адресу слева от команды.
</p>

<p>
<img src="../../images/059.png">
</p>

<p>
Появится такое же окошко, как при добавлении комментария через Hex Editor. Если прописывать комментарий в поле ввода <text class="section">Comment</text>, он будет показан серым цветом в Debugger'е под основным комментарием.
</p>

<p>
<img src="../../images/060.png">
</p>

<div class="tip">
<p>
Без добавления хотя бы 1 символа в поле ввода <text class="section">Name</text> комментарий создать не получится, а записывать что-то в поле <text class="section">Comment</text> не обязательно. Не все символы можно использовать, например <text class="object">#</text> удаляется. Некоторые символы могут портить отображение комментария в поле ввода Name, такие как <text class="object">-</text> (в случае с RAM адресами).
<br>
<br>
Через Debugger можно добавлять комментарии и на RAM адреса, когда те используются в командах. Однако не получится добавить комментарий на адреса диапазона $0000-$00FF, если они отображаются без двух лишних нулей, такие адреса не будут кликабельны. Можно перейти на этот адрес при помощи кнопки <text class="button">Seek To</text> в Debugger'е и добавить комментарий к адресу как к коду, или же сделать это через окно Hex Editor.
</p>
</div>

<p>
Добавь остальные комментарии как на скрине. Поначалу такое возможно выглядит не очень эстетично, но к этому быстро привыкаешь. Обрати внимание, что комментарий адреса $C2DD также отображается в команде <span class="debugger_color_blue">BNE</span>, потому что в ней прыжок на этот адрес. В ссылках на адреса, как в этом случае, серый тест из поля Comment виден не будет.
</p>

<p>
<img src="../../images/061.png">
</p>

<p>
Для редактирования комментария можно кликнуть правой кнопкой мыши по синему тексту (и в ссылках тоже), а не только по адресу.
</p>

<div class="tip">
<p>
Комментарии на код также хранятся в одноименном <text class="file">.nl</text> файле с ROM'ом, но в отличие от комментариев на RAM адреса они будут записаны в файл, соответствующий номеру банку памяти, где находится этот код.
<br>
<br>
<img src="../../images/093.png">
<br>
<br>
Номер банка указан в Debugger'е справа от адреса команды.
<br>
<br>
<img src="../../images/094.png">
</p>
</div>

<p>
Теперь перейдем к тестам. Следи за флагом <text class="object">Z</text> в Debugger'е. Он отвечает за то, что результат какой-то операции равен или не равен #00.
</p>

<p>
<img src="../../images/062.png">
</p>

<p>
Если галочка не стоит, значит флаг = 0, то есть в результате какой-то операции получился любой байт кроме #00. Если же галочка выставлена, значит флаг = 1, то есть где-то получился именно байт #00. В данный момент галочка не стоит, потому что результат команды <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span> не равен #00, ведь байт #05 ≠ #00.
</p>

<div class="tip">
<p>
Не все команды процессора обновляют состояние флага Z. Любая команда <span class="debugger_color_blue">LDA</span> будет обновлять флаг Z. Команда <span class="debugger_color_blue">STA</span> не обновляет флаг Z (она вообще никакие флаги не обновляет). Поэтому когда читаешь код, и видишь команду, которая проверяет флаги, надо искать команды, обновляющие их, которые выполнялись до этой команды проверки флагов, и не зацикливаться на остальных командах.
</p>
</div>

<p>
Выполни команду <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span>. Флаг Z все еще будет = 0, потому что процессор прочитал адрес $0083, и байт в нем ≠ #00, ведь сейчас режим игры 2 Players и байт #01. Теперь выполни команду <span class="debugger_color_blue">BNE</span> <span class="debugger_color_green">$C2DD</span>, проверяющую на "результат не равен #00". Она проверит флаг Z, увидит что Z = 0, условие команды выполнится, и код перейдет на $C2DD, перепрыгнув участок с обнулением $0052.
</p>

<p>
Теперь загрузи сохранение, снова выполни команду <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span>, но в этот раз попробуй подменить байт в регистре A на #00. Затем выполни команду <span class="debugger_color_blue">BNE</span> <span class="debugger_color_green">$C2DD</span>. Ты получишь точно такой же результат как и в прошлый раз, потому что команду <span class="debugger_color_blue">BNE</span> совершенно не интересует какой байт находится в регистре A, ее интересует <text class="underline">только</text> флаг Z. А этот флаг обновляется в момент чтения $0083.
</p>

<p>
Загрузи сохранение, и подмени байт в $0083 на #00 через Hex Editor. Потом выполни команду <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span>, и теперь наконец-то флаг Z будет = 1, потому что результат чтения $0083 был равен #00. Выполни команду <span class="debugger_color_blue">BNE</span> <span class="debugger_color_green">$C2DD</span>. Условие команды не выполнится, ведь на этот раз Z = 1, поэтому код обнулит адрес $0052.
</p>

<p>
Загрузи сохранение, выполни <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$83</span> и сделай новое сохранение. Сейчас у тебя Z = 0, потому что в твоем сохранении $0083 = #01. Вручную кликни 1 раз левой кнопкой мыши на флаг Z чтобы выставить галочку, тем самым ты подменишь состояние флага, и теперь Z = 1. Выполнив команду <span class="debugger_color_blue">BNE</span> <span class="debugger_color_green">$C2DD</span> код начнет обнулять $0052, потому что условие команды <span class="debugger_color_blue">BNE</span> не выполнилось.
</p>

<div class="tip">
<p>
Сохранения хранят состояния флагов, как и байты регистров. Ты точно также можешь создавать сохранения с различными состояниями флага перед выполнением команды, которая будет проверять состояние этого флага, и смотреть как это сказывается на игре. Это может помочь определить предназначение каждой из двух развилок кода в зависимости от этой команды, и это знание (или просто свои догадки/предположения) ты можешь записать комментариями в коде. В нашем примере развилка - обнулить/не обнулить жизни 2-го игрока.
</p>
</div>

<a name="007"></a><p class="subtitle">Прочие виды Breakpoint'ов</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
До сих пор мы использовали только Write Breakpoint. Существуют еще 3 вида Breakpoint'ов - <text class="object">Read</text> (чтение), <text class="object">Execute</text> (выполнение) и <text class="object">Forbit</text> (запрет). Дополнительно расскажу еще про парочку возможностей Debugger'а.
</p>

<h2>Execute Breakpoint</h2>

<p>
В отличие от Write, который ставится на адреса RAM, Execute ставится на адреса кода из NES Memory. Взглянем на наш участок кода целиком (обычно команды <span class="debugger_color_blue">RTS</span> помогают определить начало и конец участка).
</p>

<p>
<a class="data-lity" href="../../images/064.png" data-lity><img height="200" src="../../images/064.png"></a>
</p>

<p>
Перед выполнением команды <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$05</span> явно выполнялся еще какой-то код. Ты можешь создать Execute Breakpoint, условием которого будет остановить эмулятор в том случае, когда код игры будет пытаться пройти по этому месту. Например ты заприметил какой-то интересный код и хочешь узнать когда именно он будет выполняться. Ты просто ставишь на него Execute Breakpoint и играешь до тех пор, пока он не сработает. Если он срабатывает не ежекадрово, а только при каком-то определенном игровом моменте, это намекнет тебе на значение этого участка кода.
</p>

<p>
В Debugger'е предусмотрено очень удобное создание таких Execute условий, для этого нужно дважды кликнуть на адресе слева от команды. Попробуем это на команде <span class="debugger_color_blue">LDX #</span><span class="debugger_color_green">$15</span> вверху участка.
</p>

<p>
<img src="../../images/065.png">
</p>

<p>
Дважды кликни на адрес $C2B3 слева от команды. В появившемся окне уже будет записан нужный адрес $C2B3, а также выставлен тип Execute для Breakpoint'а. Тебе достаточно сразу нажать <text class="button">OK</text>.
</p>

<p>
<img src="../../images/066.png">
</p>

<div class="tip">
<p>
В поле ввода <text class="section">Condition</text> изначально записано дополнительное условие при добавлении Execute Breakpoint'а через двойной клик по адресу. Такие условия можно прописывать самому, об этом будет отдельная статья. Текущее условие <text class="object">K==#00</text> означает выполнение кода по адресу $C2B3 конкретно в банке под номером #00. Номер банка указан слева от адреса команды.
<br>
<br>
<img src="../../images/067.png">
<br>
<br>
Поскольку номер банка может меняться, если игровой маппер это позволяет, по одному и тому же адресу в разное время может находиться разный код. Поэтому необходима такая запись чтобы условие Breakpoint'а было более конкретным, то есть чтобы этот Breakpoint не срабатывал во всех возможных банках, а только в каком-то одном. В Battle City нету переключения банков, поэтому здесь данное условие не обязательно.
</p>
</div>

<p>
Твой новый созданный Breakpoint появится там же, где и остальные. Буква <text class="object">X</text> будет означать Execute, а слово <text class="object">Condition</text> значит что в Breakpoint'е есть некое дополнительное условие, записанное в поле ввода <text class="section">Condition</text> (в нашем случае это K==#00).
</p>

<p>
<img src="../../images/068.png">
</p>

<p>
Если Write Breakpoint $0051 у тебя деактивирован, активируй его двойным кликом. Теперь как обычно сделай <text class="button">Reset</text> и нажми <text class="button">Start</text> на главном экране. Breakpoint, который спровоцировал остановку игры и вызвал Debugger, будет выделен синим цветом.
</p>

<p>
<img src="../../images/069.png">
</p>

<p>
Как и ожидалось, игра остановилась там, где ей было приказано - при <text class="underline">попытке</text> выполнить команду по адресу $C2B3. Команда <span class="debugger_color_blue">LDX #</span><span class="debugger_color_green">$15</span> ожидает выполнения. Сделай сохранение и деактивируй Execute Breakpoint.
</p>

<p>
<img src="../../images/070.png">
</p>

<p>
Команда <span class="debugger_color_blue">LDX</span> означает <text class="object">L</text>oa<text class="object">D</text> index <text class="object">X</text> with memory (загрузить байт в индексный регистр X). Как ты уже мог догадаться, для каждого из трех регистров (A, X и Y) существуют отдельные команды, их можно легко отличить по названию (LD<text class="object">A</text>, LD<text class="object">X</text>, LD<text class="object">Y</text>), и следовательно понять их назначение. Теперь нажми кнопку <text class="button">Run</text>. Поскольку у тебя активен Write Breakpoint $0051, игра быстренько выполнит последующий код и стрелочка остановится на адресе $C2CF.
</p>

<p>
<img src="../../images/071.png">
</p>


<div class="tip">
<p>
Можно примерно оценить расстояние, пройденное кодом между этими двумя Breakpoint'ами. В Debugger'е слева отображаются счетчики тактов (<text class="object">CPU cycles</text>) и количество выполненных команд (<text class="object">Instructions</text>), начиная с последнего предыдущего срабатывания Breakpoint'а.
<br>
<br>
<img src="../../images/080.png">
<br>
<br>
Счетчик инструкций всегда будет просто увеличиваться на 1 при выполнении любой команды. <text class="object">Такт</text> - единица измерения скорости выполнения команд. Разные команды требуют разное время на выполнение, в зависимости от типа команды (минимум 2 такта). Прочитать байт, вычислить адрес, поковыряться в битах - все это требует некоторого времени. Информация в этих счетчиках вряд ли может быть полезна новичку. Обычно с их помощью можно оценить нагрузку кода на процессор. Чем меньше затрачиваемых тактов, тем лучше. На счетчики можно ставить условия для остановки кода, про это будет рассказываться в отдельной статье, наряду с дополнительными условиями в поле ввода <text class="section">Condition</text> при создании Breakpoint'а.
</p>
</div>


<p>
Снова нажми кнопку <text class="button">Run</text>. Теперь игра запустится, потому что других срабатываний Breakpoint'ов пока нету, и ты можешь выбирать уровень. Поставь эмулятор на паузу и загрузи сохранение. Дальше по коду идут 2 прыжка на адрес $D9FE.
</p>

<p>
<img src="../../images/072.png">
</p>

<p>
Команда <span class="debugger_color_blue">JSR</span> означает <text class="object">J</text>ump <text class="object">S</text>aving <text class="object">R</text>eturn address (прыжок с сохранением адреса возврата), или <text class="object">J</text>ump to <text class="object">S</text>ub<text class="object">R</text>outine (прыжок в <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0" target="blank">подпрограмму</a>). Подпрограммой обычно является участок кода, который может быть использован несколько раз. Это очень сильно экономит место, если подпрограмма составлена правильно, потому что нет необходимости дважды или более раз прописывать один и тот же код, достаточно написать одну общую подпрограмму и вызывать ее через <span class="debugger_color_blue">JSR</span> когда нужно.
</p>

<p>
Чтобы посмотреть содержимое подпрограммы, не обязательно начинать выполнять команду <span class="debugger_color_blue">JSR</span>. Можно просто 1 раз кликнуть левой кнопкой мыши по адресу $D9FE, и тот автоматически скопируется в поле ввода рядом с кнопкой <text class="button">Seek To</text>.
</p>

<p>
<img src="../../images/073.png">
</p>

<p>
Нажав на <text class="button">Seek To</text>, тебя перекинет на участок по этому адресу, и ты cможешь осмотреться. Эта кнопка никак не влият на адрес стрелочки (<text class="button">Seek PC</text>), она просто служит для перехода на какой-то адрес, но текущее место выполнения кода (стрелочка) остается прежним. Чтобы вернуться обратно на стрелочку, нажми на кнопку <text class="button">Seek PC</text>.
</p>

<div class="tip">
<p>
После клика по адресу $D9FE он также скопируется в поле ввода для создания закладок справа внизу.
<br>
<br>
<p>
<img src="../../images/074.png">
<br>
<br>
Нажав кнопку <text class="button">Add</text>, добавится закладка, и ты можешь перейти на нее двойным кликом, как через кнопку <text class="button">Seek To</text>.
<br>
<br>
<img src="../../images/075.png">
<br>
<br>
Нажав кнопку <text class="button">Name</text>, вылезет окошко с предложением добавить имя закладке. Будет отображаться ограниченное количество символов, поэтому пиши сокращенно.
<br>
<br>
<img src="../../images/076.png">
<br>
<br>
Закладки <text class="underline">не</text> хранят в себе номер банка, это значит что если в игре есть переключение банков памяти, тебя будет перекидывать на нужный адрес, но возможно с другим кодом. Лучше пользоваться закладками после срабатывания Breakpoint'ов в подходящем банке.
<br>
</p>
</p>
</div>

<p>
Начнем выполнять код. Первой выполнится команда <span class="debugger_color_blue">LDX #</span><span class="debugger_color_green">$15</span>, и в регистре X ты увидишь байт #15.
</p>

<p>
<img src="../../images/079.png">
</p>

<p>
Теперь выполни команду <span class="debugger_color_blue">JSR</span> <span class="debugger_color_green">$D9FE</span>. Тебя перекинет на адрес $D9FE, там же будет находиться стрелочка. Во время прыжка в подпрограмму сохраняются все регистры и флаги, какие были до прыжка.
</p>

<p>
<img src="../../images/081.png">
</p>

<p>
По внешнему виду подпрограммы можно понять ее базовое значение. Повсюду расположены команды с участием регистра X.
</p>

<p>
<img src="../../images/082.png">
</p>

<p>
Такого вида команды (<span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$00</span><span class="debugger_color_blue">,X</span>) для вычисления итогового адреса используют регистр X, который добавляется к начальному адресу, указанному в команде (<span class="debugger_color_green">$00</span>). Итоговый адрес отображается после символа <span class="debugger_color_grey">@</span>. Сейчас у нас X = #15, поэтому <span class="debugger_color_green">$00</span> + #15 = <span class="debugger_color_grey">$0015</span>. Дальше после <span class="debugger_color_grey">=</span> как обычно указан байт, который находится в этом получившемся адресе.
</p>

<p>
<img src="../../images/083.png">
</p>

<p>
Начинай выполнять команды кнопкой <text class="button">Step Into</text>. Когда выполнишь команду <span class="debugger_color_blue">RTS</span> (<text class="object">R</text>e<text class="object">T</text>urn from <text class="object">S</text>ubroutine - выход из подпрограммы) в конце данной подпрограммы,
</p>

<p>
<img src="../../images/084.png">
</p>

<p>
тебя вернет на адрес $C2B8, поскольку <span class="debugger_color_blue">JSR</span> это прыжок с возвратом, и будет выполняться следующая команда по списку после этого <span class="debugger_color_blue">JSR</span>. Во время выполнения команды <span class="debugger_color_blue">RTS</span> сохраняются текущие регистры и флаги.
</p>

<p>
<img src="../../images/085.png">
</p>

<div class="tip">
<p>
Если подпрограмма небольшая, можно легко отследить где она заканчивается, поискав ближайшую команду <span class="debugger_color_blue">RTS</span> ниже по коду. Бывает что выходов из подпрограммы может быть сразу несколько, в зависимости от проверок на различные условия внутри этой подпрограммы, и находиться эти выходы иногда могут даже выше, чем адрес прыжка на нее в команде <span class="debugger_color_blue">JSR</span>.
</p>
</div>

<p>
Дальше идет команда <span class="debugger_color_blue">LDX #</span><span class="debugger_color_green">$1D</span> и снова прыжок в ту же подпрограмму $D9FE. Получается что подпрограмма общая, а на вход подается нужный X (в прошлый раз был X = #15), который повлияет на итоговые адреса внутри подпрограммы. Выполнив <span class="debugger_color_blue">JSR</span> и зайдя в подпрограмму, ты увидишь что итоговые адреса поменяются. Теперь <span class="debugger_color_green">$00</span> + #1D = <span class="debugger_color_grey">$001D</span>.
</p>

<p>
<img src="../../images/086.png">
</p>

<p>
Эти адреса высчитываются при помощи байта в регистре X, который указан в Debugger'е. Если ты вручную поменяешь этот байт, отображаемые итоговые адреса не будут пересчитаны сразу. Покажу пример. Сначала выполни команду <span class="debugger_color_blue">LDA #</span><span class="debugger_color_green">$00</span>, на которой сейчас стоит стрелочка. Затем открой Hex Editor, найди адрес $0020 и запиши туда #FF. Потом в Debugger'е в регистре X пропиши #20. В команде <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$00</span><span class="debugger_color_blue">,X</span> все еще указан итоговый адрес <span class="debugger_color_grey">$001D</span>. Выполни команду <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$00</span><span class="debugger_color_blue">,X</span> и посмотри в Hex Editor на адрес $0020 - в нем будет записано #00. Это значит, что хоть Debugger и не пересчитал отображаемый адрес, он учел твой текущий X = #20 и обнулил $0020 вместо $001D.
</p>

<p>
После нажатия кнопки <text class="button">Step Into</text> Debugger учел твой новый X и отобразил соответствующие итоговые адреса. Все же можно заставить Debugger пересчитывать итоговые адреса, когда ты вручную меняешь X. Для этого достаточно нажать кнопку <text class="button">Seek PC</text>, либо переключиться на другое окно, а потом снова кликнуть на Debugger.
</p>

<div class="tip">
<p>
Когда в коде видишь команды, где используется X или Y для вычисления итогового адреса, можно быть на 99% уверенным в том, что эта команда будет выполнена более 1 раза в различные промежутки времени с различными значениями регистров X или Y. Заранее нельзя сказать когда именно, это зависит от кода. Например в нашем случае эта общая подпрограмма была повторно использована сразу же на том же кадре.
<br>
<br>
Твои комментарии на RAM адреса в этом случае не всегда могут быть полезны. Допустим вот что бы ты увидел, если бы X теоретически был #51 в тот момент, когда ты смотришь на эту команду, когда просто перешел сюда по закладке, в то время как стрелочка находится в совершенно другом месте. Но это вовсе не означает, что эта подпрограмма предназначена для обнуления жизни 1-го игрока.
<br>
<br>
<img src="../../images/088.png">
<br>
<br>
Нужно постоянно держать в уме то, что во время просмотра кода итоговые адреса не всегда будут записаны правильно. Гарантированно правильно они будут записаны только тогда, когда стрелочка самостоятельно остановится на этой команде, например когда сработал Breakpoint или когда ты дошел до команды кликая на <text class="button">Step Into</text>. А раз такая команда записана в коде, значит в какой-то иной момент X/Y может быть совсем другой, но для того эти команды и существуют, чтобы при помощи лишь одной такой команды можно было работать с 256-ю адресами, ведь байт X/Y может быть в диапазоне от #00 до #FF.
<br>
<br>
Оставшийся 1% составляет недочет разработчиков, которые возможно что-то планировали, но в финальной версии игры забыли/не захотели переписывать код. Ну или какие-то другие бессмысленные случаи.
</p>
</div>

<p>
Загрузи сохранение, где твоя стрелочка находится на адресе $C2B3.
</p>

<p>
<img src="../../images/087.png">
</p>

<p>
Когда пошагово выполняешь код кнопкой <text class="button">Step Into</text>, можно проматывать выполнение подпрограмм. Это особенно полезно когда подпрограмма слишком большая, или же тебе просто не интересно смотреть что именно в ней выполняется. Для этого есть специальная кнопка <text class="button">Step Over</text>. Ее задача - быстро выполнить команду <span class="debugger_color_blue">JSR</span> и перекинуть тебя на следующую команду по списку.
</p>

<p>
<img src="../../images/089.png">
</p>

<p>
Если нажимать на кнопку <text class="button">Step Over</text>, находясь на любой другой команде кроме <span class="debugger_color_blue">JSR</span>, код будет выполняться точно также, как при нажатии кнопки <text class="button">Step Into</text>. Попробуй нажать <text class="button">Step Over</text>, когда стрелочка стоит на <span class="debugger_color_blue">JSR</span> <span class="debugger_color_green">$D9FE</span>. Подпрограмма $D9FE выполнится мгновенно, ты увидишь итоговые регистры и флаги, которые получились в результате выполнения кода этой подпрограммы, а также количество затраченных тактов и выполненных команд за это время.
</p>

<p>
Снова загрузи сохранение, но на этот раз выполни команду <span class="debugger_color_blue">JSR</span> <span class="debugger_color_green">$D9FE</span> стандартной кнопкой <text class="button">Step Into</text>. Зайдя в подпрограмму, найди в Debugger'е кнопку <text class="button">Step Out</text>.
</p>

<p>
<img src="../../images/090.png">
</p>

<p>
Ее задача - выйти из текущей подпрограммы, и тебя перекинет на то место, откуда был прыжок в подпрограмму, в которой ты сейчас находишься. Не обязательно нажимать эту кнопку сразу, ты можешь сначала выполнить парочку команд в этой подпрограмме. Нажав на кнопку <text class="button">Step Out</text>, тебя перекинет на команду <span class="debugger_color_blue">LDX #</span><span class="debugger_color_green">$1D</span>, и как в случае с кнопкой <text class="button">Step Over</text> ты увидишь полученные флаги и регистры. Счетчик тактов и команд будет накручен в зависимости от того, сколько и каких команд осталось выполнить в подпрограмме.
</p>

<p>
Вообще в большинстве случаев ты находишься в какой-то подпрограмме. Например вот этот данный участок кода, начиная с $C2B3, тоже является подпрограммой. Деактивируй Write Breakpoint $0051 и нажми кнопку <text class="button">Step Out</text>, тебя перекинет в то место, откуда был прыжок в эту подпрограмму. Получается, что внутри некой подпрограммы могут быть выполнены и другие подпрограммы, такие как <span class="debugger_color_blue">JSR</span> <span class="debugger_color_green">$D9FE</span> внутри подпрограммы $C2B3.
</p>

<p>
<img src="../../images/023.png">
</p>

<div class="tip">
<p>
Если оставить активным Write Breakpoint $0051 перед нажатием кнопки <text class="button">Step Out</text>, тогда он сработает, потому что прежде чем выйти из подпрограммы, в ней выполнится команда <span class="debugger_color_blue">STA</span> <span class="debugger_color_green">$51</span>, ведь код внутри подпрограммы выполняется как обычно. Однако кнопка <text class="button">Step Out</text> все еще продолжает свою работу. Поэтому нажав кнопку <text class="button">Run</text>, условие кнопки (выйти из текущей подпрограммы) наконец выполнится, эмулятор снова станет на паузу и выход из подпрограммы будет выполнен. Если вместо кнопки <text class="button">Run</text> повторно нажать на <text class="button">Step Out</text>, вылезет окошко, в котором сообщается что работа кнопки уже было в процессе. Выбрав <text class="button">Да</text> ты подтвердишь нажатие кнопки <text class="button">Step Out</text> и будет выполнен выход из подпрограммы. Выбрав <text class="button">Нет</text> отменится нажатие кнопки <text class="button">Step Out</text>, но кнопка продолжит свою работу, ожидая что ты нажмешь <text class="button">Run</text> для выхода из подпрограммы. Аналогично будет с кнопкой <text class="button">Step Over</text>, если код внутри подпрограммы вызовет срабатывание твоих активных Breakpoint'ов.
<br>
<br>
<img src="../../images/092.png">
<br>
<br>
Кнопки <text class="button">Step Over</text> и <text class="button">Step Out</text> не всегда срабатывают именно так, как ты того ожидаешь. Иногда будет казаться что они не работают, а потом все же срабатывают через какое-то время. Про эти особенности будет рассказано в статье с подробным изучением подпрограмм. Вообще, если по какой-то причине условие кнопки так и не было выполнено, и ты будешь делать <text class="button">Reset</text> или загружать сохранения, в будущем это условие кнопки может сработать в неожиданный момент, причем не обязательно в тот, который был запрограммирован в условии, и тебе будет казаться, что Debugger остановил игру просто так.
<br>
<br>
Нету гарантий, что если ты поставишь Execute Breakpoint на том адресе, который находится выше от того места, где у тебя уже срабатывал другой Breakpoint, то твой Execute Breakpoint сработает когда ты этого ожидаешь. То есть нет гарантий, что сработал бы Execute $C2B3, в то время как ниже по коду уже срабатывал Write Breakpoint $0051 по адресу $C2CF. Как я уже раньше говорил, в коде существует множество прыжков и развилок, и возможно в каком-то случае игра решит прыгнуть не в начало участка кода, а в середину, следовательно код в начале не выполнится и твой Execute Breakpoint не сработает.
<br>
<br>
Если ты столкнулся с такой ситуацией, когда в середине участка кода Execute Breakpoint срабатывает, а в начале участка нет, первым делом ты даешь сработать этому Breakpoint'у в середине, и затем жмешь кнопку <text class="button">Step Out</text>, чтобы выяснить откуда сюда был выполнен прыжок, а потом посмотри на адрес прыжка в найденной команде <span class="debugger_color_blue">JSR</span> через кнопку <text class="button">Seek To</text>. Если это не сработает или же тебе ничего не будет понятно, то просто попробуй поставить Execute Breakpoint чуть пониже, чем в самом начале участка, и проверить сработает ли он. Если не сработает, попробуй еще ниже, потом еще ниже. А вообще для отслеживания выполненного кода существует очень мощный инструмент под названием <text class="object">Trace Logger</text> (<text class="path">Debug -> Trace Logger</text>), который с легкостью решает такие проблемы, про него будет отдельная статья.
</p>
</div>

<h2>Read и Forbit Breakpoint'ы</h2>

<p>
Деактивируй свои существующие Breakpoint'ы, зайди в игре на любой уровень, поставь эмулятор на паузу когда твой танк появится на экране. В прошлой статье говорилось о том, что игра регулярно проверяет количество жизней игрока, чтобы выводить их на экране, а также чтобы проверить на отсутствие жизней для вывода Game Over'а. Раз мы знаем что игра проверяет адрес, значит код игры его считывает. Чтобы выловить этот код, нужно создать Read (чтение) Breakpoint.
</p>

<p>
Breakpoint'ы можно создавать и редактировать через окно Debugger'а. Если ты хочешь создать новый, жми на кнопку Add (добавить).
</p>

<p>
<img src="../../images/095.png">
</p>

<p>
В появившемся окошке в левое поле ввода вписываешь адрес $0051 (без префикса $, лишние нули слева можно не записывать), ставишь галочку на Read и жмешь <text class="button">OK</text>.
</p>

<p>
<img src="../../images/096.png">
</p>

<p>
Или же ты можешь отредактировать твой уже существующий Write Breakpoint $0051, превратив его в Read Breakpoint (если Write Breakpoint тебе больше не нужен). Кликаешь на него в списке, жмешь кнопку <text class="button">Edit</text> (изменить), в окошке снимаешь галочку с Write и выставляешь галочку Read.
</p>

<p>
<img src="../../images/100.png">
</p>

<div class="tip">
<p>
Breakpoint'ы можно создавать сразу с несколькими условиями, например Read + Write, если выставить соответствующие галочки в окошке. В созданном Breakpoint'е будет виден его тип условий.
<br>
<br>
<img src="../../images/097.png">
<br>
<br>
Для указания диапазона адресов нужно вводить конечный адрес в правое поле ввода. Например для создания диапазона $0051-$0055 нужно ввести туда $0055. Тогда выставленное условие для текущего Breakpoint'а будет распространяться сразу на 5 адресов одновременно - $0051, $0052, $0053, $0054 и $0055. При срабатывании такого Breakpoint'а определить какой из этих 5 адресов вызвал остановку эмулятора можно будет только изучив команду рядом со стрелочкой в Debugger'е.
<br>
<br>
<img src="../../images/098.png">
<br>
<br>
Debugger позволяет создавать до 64 любых Breakpoint'ов одновременно. Независимо от того, активированы они или нет, большое их количество может заметно сказываться на скорости работы эмулятора, в частности на ускорение горячими клавишами. Для удаления Breakpoint'а выделяешь его кликом мыши и жмешь кнопку <text class="button">Delete</text> (удалить).
<br>
<br>
<img src="../../images/099.png">
</p>
</div>

<p>
Активируй свой Read Breakpoint $0051 и нажми кнопку <text class="button">Run</text> несколько раз. Ты заметишь, что Debugger постоянно останавливает код в двух различных участках. Оба кода вызываются ежекадрово. Сначала вызывается код по адресу $C803, а через некоторое время $C730. Затем кадр заканчивается и на следующем кадре эти коды вызываются повторно. 
</p>

<p>
<img src="../../images/101.png">
</p>

<p>
Коротко расскажу про эти коды. $C803 служит для отображения количества жизней на экране. Командой <span class="debugger_color_blue">SBC #</span><span class="debugger_color_green">$01</span> код отнимает #01, поэтому на экране жизней на #01 меньше, чем байт в адресе RAM. Команда записана как <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$51</span><span class="debugger_color_blue">,X</span>, это значит что этот же код может также проверять и адрес $0052, если X = #01. Второй код $C730 проверяет на отсутствие жизней у обоих игроков при помощи считывания байта из $0051 (<span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$51</span>) и сложения его с байтом из $0052 (<span class="debugger_color_blue">ADC</span> <span class="debugger_color_green">$52</span>), и если результат равен #00, подготавливает надпись Game Over и таймеры.
</p>

<p>
Допустим эти 2 кода тебе не интересны, и ты хочешь найти остальные коды, которые будут считывать адрес $0051 в какой-то другой игровой момент. Но очевидно, что поиграть в игру в таком состоянии не получится, ведь этот Write Breakpoint $0051 срабатывает целых 2 раза за кадр, а отключив его задачу ты не выполнишь. Для этого существует тип Breakpoint'а Forbit (запрет). Ты можешь сказать Debugger'у, что в каком-то месте Read/Write Breakpoint срабатывать не должен, что позволит тебе отсеять их и найти другие срабатывания.
</p>

<p>
Также как при создании Execute Breakpoint'ов, нужно дважды кликнуть на адрес слева от команды, на которой срабатывает твой Write Breakpoint $0051, но на этот раз в окошке ты выставляешь галочку Forbit и жмешь <text class="button">OK</text>. При выставленой галочке Forbit будут игнорироваться все остальные галочки для типа Breakpoint'а.
</p>

<p>
<img src="../../images/102.png">
</p>

<p>
Forbit - условие исключительно для кода (как и Execute). При срабатывании других Breakpoint'ов эмулятор предварительно проверит весь список в поисках Forbit на адресе команды, и если такой существует, срабатывание будет проигнорировано. Выставляешь 2 Forbit Breakpoint'а на адреса $C803 и $C730, и теперь твой Write Breakpoint $0051 не будет срабатывать в этих местах.
</p>

<p>
<img src="../../images/103.png">
</p>

<p>
Нажав <text class="button">Run</text> ты вскоре обнаружишь еще одно срабатывание по адресу $D45E. Это код, отвечающий за PRNG (PseudoRandom Number Generator - <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB" target="blank">генератор псевдослучайных чисел</a>, или просто рандом, часто записывают как RNG без Pseudo), похожие встречаются во многих играх. Игра обычно ежекадрово по-очереди считывает по одному адресу из какой-то области RAM и производит с ними некие математические операции, в итоге получая якобы рандомный байт.
</p>

<p>
<img src="../../images/104.png">
</p>

<p>
Такому коду не интересен тот факт, что адрес $0051 отвечает за жизни. Просто в данный момент так получилось, что X = #51, поэтому команда <span class="debugger_color_blue">ADC</span> <span class="debugger_color_green">$00</span><span class="debugger_color_blue">,X</span> вызвала срабатывание Write Breakpoint'а. Поставь на него Forbit как и на предыдущие 2 участка. В итоге у тебя будет 3 Forbit Breakpoint'а. Это позволит тебе найти другие коды, считывающие адрес $0051, например после смерти твоего игрока или при взятии бонуса "жизнь", когда игра будет считывать адрес с жизнями, чтобы отнять/прибавить к нему #01.
</p>

<p>
Касаемо бонусов, при помощи Forbit Breakpoint'ов можно также проследить что происходит при взятии разных бонусных предметов. Если выбить бонус, сохраниться и сделать Read Breakpoint на адресе с номером бонуса $0088, твой Breakpoint будет ежекадрово срабатывать на коде по адресу $E263, который определяет какое изображение вывести бонусу в зависимости от его номера. Этот код нам не интересен, поэтому ставим на него Forbit. Еще Breakpoint будет срабатывать на адресе $D45E, где вычисляется рандом, как в случае с адресом жизней, но если у тебя уже активен Forbit на этом коде, и срабатывания Read Breakpoint'а не будет.
</p>

<p>
Нужный нам код появится лишь в момент взятия бонуса, поэтому мы предварительно поставили Forbit на других участках кода. После взятия бонуса твой Read Breakpoint сработает на коде по адресу $E9AC.
</p>

<p>
<img src="../../images/114.png">
</p>

<p>
Если ты немного знаком с командами процессора, ты можешь определить что это не тот код, который нам нужен. В регистр A грузится байт из $0088 через команду <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$88</span>. Затем команда <span class="debugger_color_blue">BMI</span> проверяет на отрицательный байт, то есть на байт диапазона #80-#FF. В нашем случае проверка не сработает, потому что в $0088 у нас сейчас байт #00-#06, поэтому будет выполнена следующая команда <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$46</span>. Для нас это означает то, что регистр A сразу же потеряет считанный байт из $0088 и заменит его на байт из $0046, то есть процессор уже не будет владеть информацией о номере бонуса. Значит будем искать следующие срабатывание Read Breakpoint'а, а на адресе $E9AC можешь поставить Forbit.
</p>

<p>
Следующее срабатывание будет по адресу $E9CA, и это тот самый код, который мы искали. Сделай здесь сохранение.
</p>

<p>
<img src="../../images/115.png">
</p>

<p>
Не вдаваясь в чрезмерные подробности, скажу что в зависимости от номера бонуса вычисляется адрес прыжка на определенный участок кода, где игрок будет получать ништяки от конкретного бонуса. Сам прыжок находится по адресу $E9DA, команда <span class="debugger_color_blue">JMP (</span><span class="debugger_color_green">$0011</span><span class="debugger_color_blue">)</span>. Такой прыжок не имеет конкретного адреса, адрес вычисляется исходя из байтов, записанных по адресам $0011 и $0012, и в данном коде ты можешь увидеть записи по этим адресам. Если после выполнения команды <span class="debugger_color_blue">LDA</span> <span class="debugger_color_green">$88</span> подменить байт в регистре A на #00-#06, ты в итоге будешь получать различные адреса для прыжка и при желании сможешь посмотреть коды со всеми бонусами. А если бы твоей задачей было сделать хак Battle City, тебе следовало бы записать комментарии в Debugger'е на все эти бонусы после прыжка на соответствующие участки кода.
</p>

<a name="008"></a><p class="subtitle">Содержимое ROM File</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
ROM'ы разных игр могут отличаться по размеру и по мапперу. Чтобы эмулятор понимал как именно ему нужно эмулировать конкретный ROM, для этого в самом начале каждого ROM'а находится специальная строчка из 16-ти байтов, называющаяся <text class="object">хедер</text> (header - заголовочный файл). Если перейти в ROM File и кликнуть на любой байт в самой первой строчке, Hex Editor в своем окне сообщит тебе что это хедер.
</p>

<p>
<img src="../../images/108.png">
</p>

<div class="tip">
<p>
Самый популярный формат хедера для NES-игр это <a href="https://wiki.nesdev.com/w/index.php/INES" target="blank">iNES</a> header, он записан как NES в начале строки. Слово NES получается из байтов 4E 45 53 по таблице символов <a href="https://ru.wikipedia.org/wiki/ASCII" target="blank">ASCII</a>, которая по умолчанию загружена в Hex Editor.
<br>
<br>
<p>
<img src="../../images/109.png">
</p>
<br>
Hex Editor в эмуляторе FCEUX не позволит тебе редактировать хедер, это нужно делать через альтернативный Hex-редактор. Сразу скажу, что одно только изменение хедера скорее всего ни к чему хорошему не приведет, нужны дополнительные манипуляции с кодом игры чтобы все заработало.
<br>
<br>
Значительно реже может встречаться <a href="https://wiki.nesdev.com/w/index.php/UNIF" target="blank">UNIF</a> header, который распознается не всеми эмуляторами. Также существует версия iNES header'a <a href="https://wiki.nesdev.com/w/index.php/NES_2.0" target="blank">2.0</a>, но я не встречал на нем ни одной игры. Эти 2 хедера предназначены для расширения возможностей NES игр в плане управления памятью.
</p>
</div>

<p>
В эмуляторе выбери <text class="path">Help -> Message Log</text>.
</p>

<p>
<img src="../../images/105.png">
</p>

<p>
Откроется окошко, в начале которого записана расшифровка байтов из хедера.
</p>

<p>
<a class="data-lity" href="../../images/106.png" data-lity><img height="200" src="../../images/106.png"></a>
</p>

<div class="tip">
<p>
Также в окне ты найдешь лог некоторых твоих действий в эмуляторе, в частности на какие слоты ты сохранялся. Если ты забыл куда сохранялся, и не хочешь случайно перезаписать это сохранение, а эмулятор не отображает сообщения на экране, просто открой лог и посмотри.
<br>
<br>
Напомню, что ты можешь отменить/вернуть перезапись слота клавишами <text class="button">Ctrl</text> + <text class="button">Z</text> по умолчанию, кликнув на эмулятор, но это работает только для последнего перезаписанного слота.
</p>
</div>

<p>
Разберем что означает информация по ROM'у в начале лога.
</p>

<p>
<img src="../../images/107.png">
</p>

<h2>PRG ROM</h2>

<p>
Это размер памяти PRG (Programm ROM), то есть код игры и различные байты данных. Число перед <text class="object">x</text> - множитель страниц по 16 килобайт. 1 страница размером 16 килобайт = 4000h байт (при помощи постфикса <text class="object">h</text> и шестнадцатеричного числа я буду указывать в статьях размер какой-то области). Учитывая что в ROM File хедер всегда находится на первой строчке, память PRG начинается с 0x00010. Кликнув на любой байт из 0x00010-0x0400F, Hex Editor в окне сообщит тебе что это байт из области PRG.
</p>

<p>
<img src="../../images/110.png">
</p>

<p>
Если маппер это позволяет, можно расширить ROM и добавить больше памяти PRG, после чего можно будет подключать эти новые страницы в NES Memory и использовать их по своему усмотрению. Например чтобы добавить в игру больше уровней. Battle City - примитивная и несложная игра, поэтому ей достаточно минимальных 16 килобайт PRG.
</p>

<div class="tip">
<p>
Из-за особенностей маппера, использущегося в Battle City, область 0x00010-0x0400F дублируется и в $8000-$BFFF, и в $C000-$FFFF в NES Memory. Но код Battle City работает только с $C000-$FFFF.
</p>
</div>

<h2>CHR ROM</h2>

<p>
Это размер памяти CHR (Character ROM), то есть байты, из которых составляются тайлы. Эти тайлы в последствии могут быть использованы для отрисовки фона или спрайтов (объектов). 1 страница размером 8 килобайт = 2000h байт. С учетом хедера и текущего размера PRG, память CHR в ROM File расположена в 0x04010-0x0600F. Hex Editor также сообщает что это CHR после клика по байтам в этой области.
</p>

<p>
<img src="../../images/111.png">
</p>

<p>
Байты CHR загружаются в видеопамять игры, которую можно посмотреть в <text class="path">Hex Editor -> View -> PPU Memory</text> по адресам $0000-$1FFF, а <text class="object">PPU Viewer</text> отображает эти байты как графику. Каждая строчка из 16-ти байтов содержит информацию о том, как будет выглядеть 1 тайл и какие цвета из палитры он будет использовать, подробнее об этом узнаешь в разделах с графикой.
</p>

<div class="tip">
<p>
Ты конечно можешь попробовать менять байты в PPU Memory вручную, но я очень не советую этого делать без веской причины. Hex Editor не будет хранить эти изменения, и ты не сможешь вернуть их назад. Сохранения в эмуляторе не помогут. А сохранив ROM через Hex Editor ты получишь испорченные тайлы в тех местах, где ты менял байты. Лучше заранее сделай копию ROM'а если захочешь побаловаться. Для перерисовки графики есть удобные программы, например универсальная <a href="https://www.romhacking.net/utilities/958/" target="blank">YY-CHR</a>, про которую будет рассказано в разделах с графикой. Для некоторых популярных игр можно найти специализированные редакторы графики.
</p>
</div>

<p>
Как и в случае с памятью PRG, если маппер это позволяет, игра может иметь гораздо больше памяти CHR, и подключать новые области с байтами в видеопамять. Например если у игры есть какое-то меню с логотипом и опциями, то для этого экрана игра подключит область тайлов с алфавитом и графикой логотипа. А когда ты начнешь играть на уровне, игра переключит эти тайлы на новые тайлы с графикой уровня. В Battle City графика уровней довольно примитивная, поэтому она прекрасно обходится одним и тем же набором тайлов на всех существующих экранах.
</p>

<div class="tip">
<p>
Некоторые игры вообще не имеют встроенной памяти CHR, например Contra (U), в логе будет написано 0 x 8KiB. Такие игры вместо переключения банков CHR пишут байты напрямую в видеопамять, что позволяет им налету перерисовывать какие-то тайлы вместо замены всей страницы тайлов целиком. Такая память называется CHR RAM, а не CHR ROM. У CHR RAM есть свои преимущества и недостатки.
<br>
<br>
Еще у игр с CHR RAM последние 2000h байт в самом конце ROM File будут дублировать $0000-$1FFF из PPU Memory. Якобы это и есть та область CHR, которая в ROM File должна идти сразу после PRG.
<br>
<br>
Некоторые игры используют CHR еще и для хранения игровых данных, а не только для тайлов. Например игра Kunio-kun no Nekketsu Soccer League считывает из них байты с номерами тайлов для отрисовки фона, экономя место в PRG.
</p>
</div>

<h2>ROM CRC32 и ROM MD5</h2>
Это контрольные суммы, которые эмулятор вычисляет из байтов ROM File, но без хедера, то есть без учета строчки $0000-$000F (не знаю зачем так сделано). Указание контрольных сумм пригодится для выкладывания патчей на специальных сайтах с хаками игр, например на <a href="https://www.romhacking.net/" target="blank">RHDN</a>, чтобы пользователь не ошибся с ROM'ом, на который нужно наложить этот патч. Для правильного вычисления контрольной суммы я пользуюсь <a href="https://hashtab.ru/" target="blank">HashTab</a>, которая встраивается в окно Windows "Свойства" и откуда легко скопировать эти данные.

<p>
<a class="data-lity" href="../../images/112.png" data-lity><img height="200" src="../../images/112.png"></a>
</p>

<p>
Также программа позволяет сравнивать 2 файла. Это пригодится когда ты скачал ROM'ы (обычно хаки) с разных ресурсов, и хочешь узнать отличаются ли они. Неважно какие названия у этих файлов, ведь если их контрольная сумма совпадает - файлы одинаковые. Но если не хочешь устанавливать программу, можешь просто воспользоваться <a href="http://onlinemd5.com/" target="blank">онлайн</a> генератором. Или заархивируй файл, затем открой его в <a href="https://www.win-rar.com" target="blank">WinRar</a>, там будет указан CRC32.
</p>

<p>
<img src="../../images/164.png">
</p>

<h2>Mapper и Mapper name</h2>

<p>
Номер маппера и его название. Мапперов существует очень много, как официальных, так и пиратских. Их список и техническую информацию по ним можно посмотреть <a href="https://wiki.nesdev.com/w/index.php/Mapper" target="blank">здесь</a>. В Battle City используется маппер № 0, который называется <a href="https://wiki.nesdev.com/w/index.php/NROM" target="blank">NROM</a>. Это самый простой из существующих мапперов, он не умеет переключать банки PRG или CHR, поэтому максимальный размер PRG у него 32 килобайта ($8000-$FFFF в NES Memory), а CHR - 8 килобайт ($0000-$1FFF в PPU Memory), то есть ровно столько, сколько может быть максимально без переключения банков.
</p>

<h2>Mirroring</h2>

<p>
Зеркаливание, относится к формату расположения Nametable (таблица имен) в видеопамяти, отвечающую за тайлы фона и его атрибуты. Они расположены в PPU Memory по адресам $2000-$2FFF, каждый Nametable размером 400h. Mirroring чаще всего бывает Horizontal или Vertical, подробнее можно почитать <a href="https://wiki.nesdev.com/w/index.php/Mirroring#Nametable_Mirroring" target="blank">здесь</a>. Тип Mirroring'а выбирается исходя из того, как именно в игре будет скроллиться экран.
</p>

<div class="tip">
<p>
Несмотря на записанный в хедере байт, отвечающий за Mirroring, его тип можно изменять записью в определенный регистр на некоторых мапперах.
</p>
</div>

<h2>Battery-backed</h2>

<p>
Показывает наличие батарейки. На некоторых мапперах есть возможность подключить батарейку в NES Memory по адресам $6000-$7FFF. Она может быть использована как обычная RAM, так и место хранения дополнительных кодов и данных без необходимости переключать банки. Я очень активно ей пользуюсь, и тебя потом научу.
</p>

<div class="tip">
<p>
Несмотря на записанный в хедере байт, отвечающий за батарейку, в FCEUX он игнорируется, насчет других эмуляторов точно не знаю. FCEUX позволяет считывать данные с батарейки и записывать в нее по умолчанию, а Nestopia включает/отключает эту возможность после записи в определенный регистр на маппере.
</p>
</div>

<h2>Trained</h2>

<p>
Показывает наличие <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D0%B9%D0%BD%D0%B5%D1%80" target="blank">трейнера</a>. Возможно ты уже сталкивался с трейренами для компьютерных игр, которые позволяют включать/отключать читы, например бесконечное здоровье и патроны. Трейнеры для NES это что-то подобное. До начала игры появляется специальный экран, где ты можешь включить/отключить какие-то игровые читы, а потом игра запускается. Хотя теоретически трейнер можно сделать и по-другому.
</p>

<p>
<a class="data-lity" href="../../images/113.png" data-lity><img height="200" src="../../images/113.png"></a>
</p>

<div class="tip">
<p>
Эмуляторы Nestopia и Mednafen не поддерживают трейнеры, так что эта штука по сути бесполезная. Гораздо легче сделать простенький читерский хак, чем возиться с подключением трейнера. Я нашел только 1 игру с рабочим трейреном, как-нибудь напишу по ней небольшую познавательную статью.
</p>
</div>

<a name="009"></a><p class="subtitle">Заключение</p>
<p>
<a href=#000>Назад к содержанию</a>
</p>

<p>
Все команды процессора будут подробно расписаны в следующем разделе, так что не переживай, если сейчас тебе в коде игры что-то было не понятно. Примеры были взяты просто для ознакомления, чтобы ты немного потренировался с Debugger'ом и в дальнейшем тебе было проще усвоить информацию.
</p>

<p>
Подведем основные итоги статьи:
</p>

<p>
<li>В твоем распоряжении 4 вида Breakpoint'ов - Read для чтения, Write для записи, Execute для выполнения и Forbit для запрета.</li>
<li>Можно добавлять комментарии к адресам RAM через Hex Editor и к коду через Debugger.</li>
<li>Для быстрого перемещения к местоположению кода в ROM File нужно в Debugger'е кликнуть правой кнопкой мыши по серой полоске слева от адреса команды во время паузы эмулятора.</li>
<li>Существуют 3 регистра процессора - A, X и Y, содержимое которых можно посмотреть в Debugger'е, а также вручную изменять эти байты (и флаги) пока эмулятор на паузе.</li>
<li>Для быстрого перемещения по коду в Debugger'е можно создавать закладки или воспользоваться кнопкой <text class="button">Seek To</text>.</li>
<li>Для изменения места выполнения кода (стрелочка) и для быстрого возврата к месту выполнения воспользуйся кнопкой <text class="button">Seek PC</text>.</li>
<li>Для перепрыгивания через подпрограммы (команды <span class="debugger_color_blue">JSR</span>) есть кнопка <text class="button">Step Over</text>.</li>
<li>Для быстрого выхода из подпрограммы жми кнопку <text class="button">Step Out</text>.</li>
<li>Можно делать различные сохранения при просмотре кода пока эмулятор на паузе. Сохранение хранит в себе адрес <text class="button">Seek PC</text> (стрелочка), а также байты в регистрах и флаги.</li>
<li>Лог хранит список некоторых твоих последних действий в эмуляторе, в частности используемые для сохранения слоты.</li>
</p>

<p>
Внимательно изучай каждое срабатывание Breakpoint'а, особенно пока еще учишься. Если это Write Breakpoint, обращай внимание на то, какая именно команда делает запись в адрес (<span class="debugger_color_blue">LDA</span>, <span class="debugger_color_blue">LDX</span> или <span class="debugger_color_blue">LDY</span>), и смотри какой байт записан в соответствующем регистре, чтобы понять то ли это срабатывание Breakpoint'а или стоит поискать другое.
</p>

<p>
Для поиска адресов (и кода) можно разбирать на что влияют читы <a href="https://ru.wikipedia.org/wiki/Game_Genie" target="blank">Game Genie</a> для твоей игры, их легко найти в интернете, например <a href="https://etherealgames.com/game-genie-code-index/nintendo-nes" target="blank">здесь</a>. Это временные читы, которые слегка изменяют код игры, обычно с целью создания несложных читерских хаков вроде бесконечных жизней и патронов, так что тебе будет хотя бы с чего начать если вдруг уж совсем ничего не получается (что навряд ли). Читы нужно вводить в окне <text class="object">Game Genie</text>, которое вызывается через <text class="path">Debug -> Game Genie Encoder/Decoder</text>, а список читов посмотреть в окне <text class="object">Cheats</text>, которое вызывается через <text class="path">Tools -> Cheats</text>. Про Game Genie будет отдельная статья.
</p>

<br>
<hr>
<br>

<div id="sigCommentsBlock"></div>
<script type="text/javascript">
	(function(){
		var host_id = '3239';
		var script = document.createElement('script');
		script.type = 'text/javascript';
		script.async = true;
		script.src = '//sigcomments.com/chat/?host_id='+host_id;
		var ss = document.getElementsByTagName('script')[0]; 
		ss.parentNode.insertBefore(script, ss);
	})();
</script>

</body>

</html>